(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_dart"

let parse_source_string ?src_file contents =
  let ts_parser = create_parser () in
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  let ts_parser = create_parser () in
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [
  "comment";
  "documentation_comment";
]

let children_regexps : (string * Run.exp option) list = [
  "pat_a3d33dc", None;
  "super", None;
  "pat_d6c261f", None;
  "typedef", None;
  "logical_or_operator", None;
  "unused_escape_sequence", None;
  "logical_and_operator", None;
  "mixin", None;
  "block_comment", None;
  "import", None;
  "exclamation_operator", None;
  "bitwise_operator",
  Some (
    Alt [|
      Token (Literal "&");
      Token (Literal "^");
      Token (Literal "|");
    |];
  );
  "semgrep_named_ellipsis", None;
  "assignment_operator",
  Some (
    Alt [|
      Token (Literal "=");
      Token (Literal "+=");
      Token (Literal "-=");
      Token (Literal "*=");
      Token (Literal "/=");
      Token (Literal "%=");
      Token (Literal "~/=");
      Token (Literal "<<=");
      Token (Literal ">>=");
      Token (Literal ">>>=");
      Token (Literal "&=");
      Token (Literal "^=");
      Token (Literal "|=");
      Token (Literal "??=");
    |];
  );
  "equality_operator", None;
  "part_of_builtin", None;
  "nullable_type", None;
  "implements", None;
  "pat_4fd4a56", None;
  "static", None;
  "additive_operator_", None;
  "identifier_dollar_escaped", None;
  "final_builtin", None;
  "increment_operator", None;
  "minus_operator", None;
  "external_builtin", None;
  "this", None;
  "required", None;
  "case_builtin", None;
  "break_builtin", None;
  "template_chars_double_single", None;
  "decimal_integer_literal", None;
  "nullable_selector", None;
  "void_type", None;
  "as_operator", None;
  "set", None;
  "relational_operator",
  Some (
    Alt [|
      Token (Literal "<");
      Token (Literal ">");
      Token (Literal "<=");
      Token (Literal ">=");
    |];
  );
  "rethrow_builtin", None;
  "null_literal", None;
  "semicolon", None;
  "covariant", None;
  "shift_operator_",
  Some (
    Alt [|
      Token (Literal "<<");
      Token (Literal ">>");
      Token (Literal ">>>");
    |];
  );
  "inferred_type", None;
  "multiplicative_operator_",
  Some (
    Alt [|
      Token (Literal "*");
      Token (Literal "/");
      Token (Literal "%");
      Token (Literal "~/");
    |];
  );
  "export", None;
  "true", None;
  "template_chars_double", None;
  "hex_integer_literal", None;
  "tilde_operator", None;
  "identifier", None;
  "pat_05bf793", None;
  "function_builtin_identifier", None;
  "template_chars_raw_slash", None;
  "sealed", None;
  "deferred", None;
  "as", None;
  "interface", None;
  "operator", None;
  "late_builtin", None;
  "get", None;
  "const_builtin", None;
  "factory", None;
  "template_chars_single_single", None;
  "semgrep_ellipsis", None;
  "new_builtin", None;
  "base", None;
  "abstract", None;
  "documentation_block_comment", None;
  "decimal_floating_point_literal", None;
  "false", None;
  "assert_builtin", None;
  "template_chars_single", None;
  "pat_0017fb0", None;
  "tok_is", None;
  "sub_string_test",
  Some (
    Seq [
      Token (Literal "$");
      Token (Name "pat_a3d33dc");
    ];
  );
  "escape_sequence",
  Some (
    Token (Name "unused_escape_sequence");
  );
  "negation_operator",
  Some (
    Token (Name "exclamation_operator");
  );
  "bitwise_operator_",
  Some (
    Token (Name "bitwise_operator");
  );
  "additive_operator",
  Some (
    Token (Name "additive_operator_");
  );
  "postfix_operator",
  Some (
    Token (Name "increment_operator");
  );
  "external", Some (Token (Name "external_builtin"););
  "rethrow_expression",
  Some (
    Token (Name "rethrow_builtin");
  );
  "shift_operator", Some (Token (Name "shift_operator_"););
  "multiplicative_operator",
  Some (
    Token (Name "multiplicative_operator_");
  );
  "break_statement",
  Some (
    Seq [
      Token (Name "break_builtin");
      Opt (
        Token (Name "identifier");
      );
      Token (Name "semicolon");
    ];
  );
  "dotted_identifier_list",
  Some (
    Seq [
      Token (Name "identifier");
      Repeat (
        Seq [
          Token (Literal ".");
          Token (Name "identifier");
        ];
      );
    ];
  );
  "type_dot_identifier",
  Some (
    Seq [
      Token (Literal ".");
      Token (Name "identifier");
    ];
  );
  "identifier_list_",
  Some (
    Seq [
      Token (Name "identifier");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "identifier");
        ];
      );
    ];
  );
  "identifier_list",
  Some (
    Seq [
      Token (Name "identifier");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "identifier");
        ];
      );
    ];
  );
  "catch_parameters",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "identifier");
      Opt (
        Seq [
          Token (Literal ",");
          Token (Name "identifier");
        ];
      );
      Token (Literal ")");
    ];
  );
  "scoped_identifier",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Token (Name "scoped_identifier");
      |];
      Token (Literal ".");
      Token (Name "identifier");
    ];
  );
  "symbol_literal",
  Some (
    Seq [
      Token (Literal "#");
      Token (Name "identifier");
    ];
  );
  "dot_identifier",
  Some (
    Seq [
      Token (Literal ".");
      Token (Name "identifier");
    ];
  );
  "continue_statement",
  Some (
    Seq [
      Token (Literal "continue");
      Opt (
        Token (Name "identifier");
      );
      Token (Name "semicolon");
    ];
  );
  "label",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Literal ":");
    ];
  );
  "comment",
  Some (
    Alt [|
      Token (Name "block_comment");
      Seq [
        Token (Literal "//");
        Token (Name "pat_d6c261f");
      ];
      Seq [
        Token (Literal "/*");
        Token (Name "pat_05bf793");
        Token (Literal "/");
      ];
    |];
  );
  "final_or_const",
  Some (
    Alt [|
      Token (Name "final_builtin");
      Token (Name "const_builtin");
    |];
  );
  "identifier_or_new",
  Some (
    Alt [|
      Token (Name "identifier");
      Token (Name "new_builtin");
    |];
  );
  "mixin_class_modifiers",
  Some (
    Seq [
      Opt (
        Token (Name "abstract");
      );
      Opt (
        Token (Name "base");
      );
      Token (Name "mixin");
      Token (Literal "class");
    ];
  );
  "class_modifiers",
  Some (
    Seq [
      Alt [|
        Token (Name "sealed");
        Seq [
          Opt (
            Token (Name "abstract");
          );
          Opt (
            Alt [|
              Token (Name "base");
              Token (Name "interface");
              Token (Literal "final");
              Token (Literal "inline");
            |];
          );
        ];
      |];
      Token (Literal "class");
    ];
  );
  "documentation_comment",
  Some (
    Alt [|
      Token (Name "documentation_block_comment");
      Seq [
        Token (Literal "///");
        Token (Name "pat_4fd4a56");
      ];
    |];
  );
  "numeric_literal",
  Some (
    Alt [|
      Token (Name "decimal_integer_literal");
      Token (Name "decimal_floating_point_literal");
      Token (Name "hex_integer_literal");
    |];
  );
  "bool_literal",
  Some (
    Alt [|
      Token (Name "true");
      Token (Name "false");
    |];
  );
  "script_tag",
  Some (
    Seq [
      Token (Literal "#!");
      Token (Name "pat_0017fb0");
      Token (Literal "\n");
    ];
  );
  "is_operator",
  Some (
    Seq [
      Token (Name "tok_is");
      Opt (
        Token (Name "exclamation_operator");
      );
    ];
  );
  "raw_string_literal_double_quotes_multiple",
  Some (
    Seq [
      Token (Literal "r\"\"\"");
      Repeat (
        Alt [|
          Token (Name "template_chars_double");
          Token (Literal "'");
          Token (Name "template_chars_raw_slash");
          Token (Literal "\"");
          Token (Name "unused_escape_sequence");
          Token (Name "sub_string_test");
          Token (Literal "$");
        |];
      );
      Token (Literal "\"\"\"");
    ];
  );
  "raw_string_literal_single_quotes",
  Some (
    Seq [
      Token (Literal "r'");
      Repeat (
        Alt [|
          Token (Name "template_chars_single_single");
          Token (Literal "\"");
          Token (Name "template_chars_raw_slash");
          Token (Name "unused_escape_sequence");
          Token (Name "sub_string_test");
          Token (Literal "$");
        |];
      );
      Token (Literal "'");
    ];
  );
  "raw_string_literal_single_quotes_multiple",
  Some (
    Seq [
      Token (Literal "r'''");
      Repeat (
        Alt [|
          Token (Name "template_chars_single");
          Token (Literal "\"");
          Token (Literal "'");
          Token (Name "template_chars_raw_slash");
          Token (Name "unused_escape_sequence");
          Token (Name "sub_string_test");
          Token (Literal "$");
        |];
      );
      Token (Literal "'''");
    ];
  );
  "raw_string_literal_double_quotes",
  Some (
    Seq [
      Token (Literal "r\"");
      Repeat (
        Alt [|
          Token (Name "template_chars_double_single");
          Token (Literal "'");
          Token (Name "template_chars_raw_slash");
          Token (Name "unused_escape_sequence");
          Token (Name "sub_string_test");
          Token (Literal "$");
        |];
      );
      Token (Literal "\"");
    ];
  );
  "prefix_operator",
  Some (
    Alt [|
      Token (Name "minus_operator");
      Token (Name "negation_operator");
      Token (Name "tilde_operator");
    |];
  );
  "external_and_static",
  Some (
    Seq [
      Token (Name "external");
      Opt (
        Token (Name "static");
      );
    ];
  );
  "binary_operator",
  Some (
    Alt [|
      Token (Name "multiplicative_operator");
      Token (Name "additive_operator");
      Token (Name "shift_operator");
      Token (Name "relational_operator");
      Token (Literal "==");
      Token (Name "bitwise_operator_");
    |];
  );
  "type_name",
  Some (
    Seq [
      Token (Name "identifier");
      Opt (
        Token (Name "type_dot_identifier");
      );
    ];
  );
  "combinator",
  Some (
    Alt [|
      Seq [
        Token (Literal "show");
        Token (Name "identifier_list");
      ];
      Seq [
        Token (Literal "hide");
        Token (Name "identifier_list");
      ];
    |];
  );
  "catch_clause",
  Some (
    Seq [
      Token (Literal "catch");
      Token (Name "catch_parameters");
    ];
  );
  "qualified",
  Some (
    Alt [|
      Seq [
        Token (Name "type_name");
        Token (Literal ".");
        Token (Name "identifier_or_new");
      ];
      Seq [
        Token (Name "type_name");
        Token (Literal ".");
        Token (Name "type_name");
        Token (Literal ".");
        Token (Name "identifier_or_new");
      ];
    |];
  );
  "additive_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "real_expression");
        Repeat1 (
          Seq [
            Token (Name "additive_operator");
            Token (Name "real_expression");
          ];
        );
      ];
      Seq [
        Token (Name "super");
        Repeat1 (
          Seq [
            Token (Name "additive_operator");
            Token (Name "real_expression");
          ];
        );
      ];
    |];
  );
  "annotation",
  Some (
    Seq [
      Token (Literal "@");
      Alt [|
        Token (Name "identifier");
        Token (Name "scoped_identifier");
      |];
      Alt [|
        Opt (
          Seq [
            Token (Name "type_arguments");
            Token (Name "arguments");
          ];
        );
        Opt (
          Token (Name "arguments");
        );
      |];
    ];
  );
  "any_argument",
  Some (
    Alt [|
      Token (Name "argument");
      Token (Name "named_argument");
    |];
  );
  "argument", Some (Token (Name "expression"););
  "argument_list",
  Some (
    Seq [
      Token (Name "any_argument");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "any_argument");
        ];
      );
      Opt (
        Token (Literal ",");
      );
    ];
  );
  "argument_part",
  Some (
    Seq [
      Opt (
        Token (Name "type_arguments");
      );
      Token (Name "arguments");
    ];
  );
  "arguments",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Token (Name "argument_list");
      );
      Token (Literal ")");
    ];
  );
  "assert_statement",
  Some (
    Seq [
      Token (Name "assertion");
      Token (Literal ";");
    ];
  );
  "assertion",
  Some (
    Seq [
      Token (Name "assert_builtin");
      Token (Name "assertion_arguments");
    ];
  );
  "assertion_arguments",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "expression");
      Opt (
        Seq [
          Token (Literal ",");
          Token (Name "expression");
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal ")");
    ];
  );
  "assignable_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "primary");
        Token (Name "assignable_selector_part");
      ];
      Seq [
        Token (Name "super");
        Token (Name "unconditional_assignable_selector");
      ];
      Seq [
        Token (Name "constructor_invocation");
        Token (Name "assignable_selector_part");
      ];
      Token (Name "identifier");
    |];
  );
  "assignable_selector",
  Some (
    Alt [|
      Token (Name "unconditional_assignable_selector");
      Token (Name "conditional_assignable_selector");
    |];
  );
  "assignable_selector_part",
  Some (
    Seq [
      Repeat (
        Token (Name "selector");
      );
      Token (Name "assignable_selector");
    ];
  );
  "assignment_expression",
  Some (
    Seq [
      Token (Name "assignable_expression");
      Token (Name "assignment_operator");
      Token (Name "expression");
    ];
  );
  "assignment_expression_without_cascade",
  Some (
    Seq [
      Token (Name "assignable_expression");
      Token (Name "assignment_operator");
      Token (Name "expression_without_cascade");
    ];
  );
  "await_expression",
  Some (
    Seq [
      Token (Literal "await");
      Token (Name "unary_expression");
    ];
  );
  "bitwise_and_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "real_expression");
        Repeat1 (
          Seq [
            Token (Literal "&");
            Token (Name "real_expression");
          ];
        );
      ];
      Seq [
        Token (Name "super");
        Repeat1 (
          Seq [
            Token (Literal "&");
            Token (Name "real_expression");
          ];
        );
      ];
    |];
  );
  "bitwise_or_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "real_expression");
        Repeat1 (
          Seq [
            Token (Literal "|");
            Token (Name "real_expression");
          ];
        );
      ];
      Seq [
        Token (Name "super");
        Repeat1 (
          Seq [
            Token (Literal "|");
            Token (Name "real_expression");
          ];
        );
      ];
    |];
  );
  "bitwise_xor_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "real_expression");
        Repeat1 (
          Seq [
            Token (Literal "^");
            Token (Name "real_expression");
          ];
        );
      ];
      Seq [
        Token (Name "super");
        Repeat1 (
          Seq [
            Token (Literal "^");
            Token (Name "real_expression");
          ];
        );
      ];
    |];
  );
  "block",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Token (Name "statement");
      );
      Token (Literal "}");
    ];
  );
  "cascade_assignment_section",
  Some (
    Seq [
      Token (Name "assignment_operator");
      Token (Name "expression_without_cascade");
    ];
  );
  "cascade_section",
  Some (
    Seq [
      Alt [|
        Token (Literal "..");
        Token (Literal "?..");
      |];
      Token (Name "cascade_selector");
      Repeat (
        Token (Name "argument_part");
      );
      Repeat (
        Token (Name "cascade_subsection");
      );
      Opt (
        Token (Name "cascade_assignment_section");
      );
    ];
  );
  "cascade_selector",
  Some (
    Alt [|
      Seq [
        Opt (
          Token (Name "nullable_selector");
        );
        Token (Name "index_selector");
      ];
      Token (Name "identifier");
    |];
  );
  "cascade_subsection",
  Some (
    Seq [
      Token (Name "assignable_selector");
      Repeat (
        Token (Name "argument_part");
      );
    ];
  );
  "cast_pattern",
  Some (
    Seq [
      Token (Name "primary_pattern");
      Token (Literal "as");
      Token (Name "type");
    ];
  );
  "conditional_assignable_selector",
  Some (
    Alt [|
      Seq [
        Token (Literal "?.");
        Token (Name "identifier");
      ];
      Seq [
        Token (Literal "?");
        Token (Name "index_selector");
      ];
    |];
  );
  "conditional_expression",
  Some (
    Seq [
      Token (Name "real_expression");
      Token (Literal "?");
      Token (Name "expression_without_cascade");
      Token (Literal ":");
      Token (Name "expression_without_cascade");
    ];
  );
  "const_object_expression",
  Some (
    Seq [
      Token (Name "const_builtin");
      Token (Name "type_not_void");
      Opt (
        Token (Name "dot_identifier");
      );
      Token (Name "arguments");
    ];
  );
  "constant_pattern",
  Some (
    Alt [|
      Token (Name "bool_literal");
      Token (Name "null_literal");
      Seq [
        Opt (
          Token (Name "minus_operator");
        );
        Token (Name "numeric_literal");
      ];
      Token (Name "string_literal");
      Token (Name "symbol_literal");
      Token (Name "identifier");
      Token (Name "qualified");
      Token (Name "const_object_expression");
      Seq [
        Token (Name "const_builtin");
        Opt (
          Token (Name "type_arguments");
        );
        Token (Literal "[");
        Token (Name "element");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "element");
          ];
        );
        Opt (
          Token (Literal ",");
        );
        Token (Literal "]");
      ];
      Seq [
        Token (Name "const_builtin");
        Opt (
          Token (Name "type_arguments");
        );
        Token (Literal "{");
        Token (Name "element");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "element");
          ];
        );
        Opt (
          Token (Literal ",");
        );
        Token (Literal "}");
      ];
      Seq [
        Token (Name "const_builtin");
        Token (Literal "(");
        Token (Name "expression");
        Token (Literal ")");
      ];
    |];
  );
  "constructor_invocation",
  Some (
    Alt [|
      Seq [
        Token (Name "type_name");
        Token (Name "type_arguments");
        Token (Literal ".");
        Token (Name "identifier");
        Token (Name "arguments");
      ];
      Seq [
        Token (Name "type_name");
        Token (Literal ".");
        Token (Name "new_builtin");
        Token (Name "arguments");
      ];
    |];
  );
  "constructor_param",
  Some (
    Seq [
      Opt (
        Token (Name "final_const_var_or_type");
      );
      Token (Name "this");
      Token (Literal ".");
      Token (Name "identifier");
      Opt (
        Token (Name "formal_parameter_part");
      );
    ];
  );
  "constructor_tearoff",
  Some (
    Seq [
      Token (Name "type_name");
      Opt (
        Token (Name "type_arguments");
      );
      Token (Literal ".");
      Token (Name "new_builtin");
    ];
  );
  "declared_identifier",
  Some (
    Seq [
      Opt (
        Token (Name "metadata");
      );
      Opt (
        Token (Name "covariant");
      );
      Token (Name "final_const_var_or_type");
      Token (Name "identifier");
    ];
  );
  "deep_ellipsis",
  Some (
    Seq [
      Token (Literal "<...");
      Token (Name "expression");
      Token (Literal "...>");
    ];
  );
  "default_formal_parameter",
  Some (
    Seq [
      Token (Name "formal_parameter");
      Opt (
        Seq [
          Token (Literal "=");
          Token (Name "expression");
        ];
      );
    ];
  );
  "default_named_parameter",
  Some (
    Alt [|
      Seq [
        Opt (
          Token (Name "metadata");
        );
        Opt (
          Token (Name "required");
        );
        Token (Name "formal_parameter");
        Opt (
          Seq [
            Token (Literal "=");
            Token (Name "expression");
          ];
        );
      ];
      Seq [
        Opt (
          Token (Name "metadata");
        );
        Opt (
          Token (Name "required");
        );
        Token (Name "formal_parameter");
        Opt (
          Seq [
            Token (Literal ":");
            Token (Name "expression");
          ];
        );
      ];
    |];
  );
  "do_statement",
  Some (
    Seq [
      Token (Literal "do");
      Token (Name "statement");
      Token (Literal "while");
      Token (Name "parenthesized_expression");
      Token (Name "semicolon");
    ];
  );
  "element",
  Some (
    Alt [|
      Token (Name "expression");
      Token (Name "pair");
      Token (Name "spread_element");
      Token (Name "if_element");
      Token (Name "for_element");
    |];
  );
  "equality_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "real_expression");
        Token (Name "equality_operator");
        Token (Name "real_expression");
      ];
      Seq [
        Token (Name "super");
        Token (Name "equality_operator");
        Token (Name "real_expression");
      ];
    |];
  );
  "expression",
  Some (
    Alt [|
      Alt [|
        Token (Name "pattern_assignment");
        Token (Name "assignment_expression");
        Token (Name "throw_expression");
        Token (Name "rethrow_expression");
        Seq [
          Token (Name "real_expression");
          Repeat (
            Token (Name "cascade_section");
          );
        ];
      |];
      Token (Name "semgrep_ellipsis");
      Token (Name "semgrep_named_ellipsis");
      Token (Name "deep_ellipsis");
    |];
  );
  "expression_statement",
  Some (
    Alt [|
      Seq [
        Token (Name "expression");
        Token (Name "semicolon");
      ];
      Token (Name "semgrep_ellipsis");
    |];
  );
  "expression_without_cascade",
  Some (
    Alt [|
      Token (Name "assignment_expression_without_cascade");
      Token (Name "real_expression");
      Token (Name "throw_expression_without_cascade");
    |];
  );
  "final_const_var_or_type",
  Some (
    Alt [|
      Seq [
        Opt (
          Token (Name "late_builtin");
        );
        Token (Name "final_builtin");
        Opt (
          Token (Name "type");
        );
      ];
      Seq [
        Token (Name "const_builtin");
        Opt (
          Token (Name "type");
        );
      ];
      Seq [
        Opt (
          Token (Name "late_builtin");
        );
        Token (Name "var_or_type");
      ];
    |];
  );
  "final_var_or_type",
  Some (
    Alt [|
      Token (Name "inferred_type");
      Token (Name "final_builtin");
      Seq [
        Opt (
          Token (Name "final_builtin");
        );
        Token (Name "type");
      ];
    |];
  );
  "finally_clause",
  Some (
    Seq [
      Token (Literal "finally");
      Token (Name "block");
    ];
  );
  "for_element",
  Some (
    Seq [
      Opt (
        Token (Literal "await");
      );
      Token (Literal "for");
      Token (Name "for_loop_parts");
      Token (Name "element");
    ];
  );
  "for_loop_parts",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "for_loop_parts_");
      Token (Literal ")");
    ];
  );
  "for_loop_parts_",
  Some (
    Alt [|
      Seq [
        Alt [|
          Token (Name "declared_identifier");
          Token (Name "identifier");
        |];
        Token (Literal "in");
        Token (Name "expression");
      ];
      Seq [
        Opt (
          Alt [|
            Token (Name "local_variable_declaration");
            Seq [
              Opt (
                Seq [
                  Token (Name "expression");
                  Repeat (
                    Seq [
                      Token (Literal ",");
                      Token (Name "expression");
                    ];
                  );
                ];
              );
              Token (Name "semicolon");
            ];
          |];
        );
        Opt (
          Token (Name "expression");
        );
        Token (Name "semicolon");
        Opt (
          Seq [
            Token (Name "expression");
            Repeat (
              Seq [
                Token (Literal ",");
                Token (Name "expression");
              ];
            );
          ];
        );
      ];
      Seq [
        Alt [|
          Token (Name "final_builtin");
          Token (Name "inferred_type");
        |];
        Token (Name "outer_pattern");
        Token (Literal "in");
        Token (Name "expression");
      ];
    |];
  );
  "for_statement",
  Some (
    Seq [
      Opt (
        Token (Literal "await");
      );
      Token (Literal "for");
      Token (Name "for_loop_parts");
      Token (Name "statement");
    ];
  );
  "formal_parameter",
  Some (
    Alt [|
      Token (Name "semgrep_ellipsis");
      Token (Name "normal_formal_parameter");
    |];
  );
  "formal_parameter_list",
  Some (
    Token (Name "strict_formal_parameter_list");
  );
  "formal_parameter_part",
  Some (
    Seq [
      Opt (
        Token (Name "type_parameters");
      );
      Token (Name "formal_parameter_list");
    ];
  );
  "function_body",
  Some (
    Alt [|
      Seq [
        Opt (
          Token (Literal "async");
        );
        Token (Literal "=>");
        Token (Name "expression");
        Token (Name "semicolon");
      ];
      Seq [
        Opt (
          Alt [|
            Token (Literal "async");
            Token (Literal "async*");
            Token (Literal "sync*");
          |];
        );
        Token (Name "block");
      ];
    |];
  );
  "function_expression",
  Some (
    Seq [
      Token (Name "formal_parameter_part");
      Token (Name "function_expression_body");
    ];
  );
  "function_expression_body",
  Some (
    Alt [|
      Seq [
        Opt (
          Token (Literal "async");
        );
        Token (Literal "=>");
        Token (Name "expression");
      ];
      Seq [
        Opt (
          Alt [|
            Token (Literal "async");
            Token (Literal "async*");
            Token (Literal "sync*");
          |];
        );
        Token (Name "block");
      ];
    |];
  );
  "function_formal_parameter",
  Some (
    Seq [
      Opt (
        Token (Name "covariant");
      );
      Opt (
        Token (Name "type");
      );
      Token (Name "identifier");
      Token (Name "formal_parameter_part");
      Opt (
        Token (Name "nullable_type");
      );
    ];
  );
  "function_signature",
  Some (
    Seq [
      Opt (
        Token (Name "type");
      );
      Alt [|
        Token (Name "get");
        Token (Name "set");
        Token (Name "identifier");
      |];
      Token (Name "formal_parameter_part");
      Opt (
        Token (Name "native");
      );
    ];
  );
  "function_type",
  Some (
    Alt [|
      Token (Name "function_type_tails");
      Seq [
        Token (Name "type_not_function");
        Token (Name "function_type_tails");
      ];
    |];
  );
  "function_type_tail",
  Some (
    Seq [
      Token (Name "function_builtin_identifier");
      Opt (
        Token (Name "type_parameters");
      );
      Opt (
        Token (Name "nullable_type");
      );
      Opt (
        Token (Name "parameter_type_list");
      );
      Opt (
        Token (Name "nullable_type");
      );
    ];
  );
  "function_type_tails",
  Some (
    Repeat1 (
      Token (Name "function_type_tail");
    );
  );
  "guarded_pattern",
  Some (
    Seq [
      Token (Name "pattern");
      Opt (
        Seq [
          Token (Literal "when");
          Token (Name "expression");
        ];
      );
    ];
  );
  "if_element",
  Some (
    Seq [
      Token (Literal "if");
      Token (Literal "(");
      Token (Name "expression");
      Opt (
        Seq [
          Token (Literal "case");
          Token (Name "guarded_pattern");
        ];
      );
      Token (Literal ")");
      Token (Name "element");
      Opt (
        Seq [
          Token (Literal "else");
          Token (Name "element");
        ];
      );
    ];
  );
  "if_null_expression",
  Some (
    Seq [
      Token (Name "real_expression");
      Repeat1 (
        Seq [
          Token (Literal "??");
          Token (Name "real_expression");
        ];
      );
    ];
  );
  "if_statement",
  Some (
    Seq [
      Token (Literal "if");
      Token (Literal "(");
      Token (Name "expression");
      Opt (
        Seq [
          Token (Literal "case");
          Token (Name "guarded_pattern");
        ];
      );
      Token (Literal ")");
      Token (Name "statement");
      Opt (
        Seq [
          Token (Literal "else");
          Token (Name "statement");
        ];
      );
    ];
  );
  "index_selector",
  Some (
    Seq [
      Token (Literal "[");
      Token (Name "expression");
      Token (Literal "]");
    ];
  );
  "initialized_identifier",
  Some (
    Seq [
      Token (Name "identifier");
      Opt (
        Seq [
          Token (Literal "=");
          Token (Name "expression");
        ];
      );
    ];
  );
  "initialized_variable_definition",
  Some (
    Seq [
      Token (Name "declared_identifier");
      Opt (
        Seq [
          Token (Literal "=");
          Token (Name "expression");
        ];
      );
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "initialized_identifier");
        ];
      );
    ];
  );
  "lambda_expression",
  Some (
    Seq [
      Token (Name "function_signature");
      Token (Name "function_body");
    ];
  );
  "list_literal",
  Some (
    Seq [
      Opt (
        Token (Name "const_builtin");
      );
      Opt (
        Token (Name "type_arguments");
      );
      Token (Literal "[");
      Opt (
        Seq [
          Token (Name "element");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "element");
            ];
          );
          Opt (
            Token (Literal ",");
          );
        ];
      );
      Token (Literal "]");
    ];
  );
  "list_pattern",
  Some (
    Seq [
      Opt (
        Token (Name "type_arguments");
      );
      Token (Literal "[");
      Opt (
        Seq [
          Token (Name "list_pattern_element");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "list_pattern_element");
            ];
          );
          Opt (
            Token (Literal ",");
          );
        ];
      );
      Token (Literal "]");
    ];
  );
  "list_pattern_element",
  Some (
    Alt [|
      Token (Name "pattern");
      Token (Name "rest_pattern");
    |];
  );
  "literal",
  Some (
    Alt [|
      Token (Name "null_literal");
      Token (Name "bool_literal");
      Token (Name "numeric_literal");
      Token (Name "string_literal");
      Token (Name "symbol_literal");
      Token (Name "set_or_map_literal");
      Token (Name "list_literal");
      Token (Name "record_literal");
    |];
  );
  "local_function_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "metadata");
      );
      Token (Name "lambda_expression");
    ];
  );
  "local_variable_declaration",
  Some (
    Alt [|
      Seq [
        Opt (
          Token (Name "metadata");
        );
        Token (Name "initialized_variable_definition");
        Token (Name "semicolon");
      ];
      Seq [
        Opt (
          Token (Name "metadata");
        );
        Token (Name "pattern_variable_declaration");
        Token (Name "semicolon");
      ];
    |];
  );
  "logical_and_expression",
  Some (
    Seq [
      Token (Name "real_expression");
      Repeat1 (
        Seq [
          Token (Name "logical_and_operator");
          Token (Name "real_expression");
        ];
      );
    ];
  );
  "logical_and_pattern",
  Some (
    Seq [
      Token (Name "relational_pattern");
      Repeat (
        Seq [
          Token (Name "logical_and_operator");
          Token (Name "relational_pattern");
        ];
      );
    ];
  );
  "logical_or_expression",
  Some (
    Seq [
      Token (Name "real_expression");
      Repeat1 (
        Seq [
          Token (Name "logical_or_operator");
          Token (Name "real_expression");
        ];
      );
    ];
  );
  "logical_or_pattern",
  Some (
    Seq [
      Token (Name "logical_and_pattern");
      Repeat (
        Seq [
          Token (Name "logical_or_operator");
          Token (Name "logical_and_pattern");
        ];
      );
    ];
  );
  "map_pattern",
  Some (
    Seq [
      Opt (
        Token (Name "type_arguments");
      );
      Token (Literal "{");
      Opt (
        Seq [
          Token (Name "map_pattern_entry");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "map_pattern_entry");
            ];
          );
          Opt (
            Token (Literal ",");
          );
        ];
      );
      Token (Literal "}");
    ];
  );
  "map_pattern_entry",
  Some (
    Alt [|
      Seq [
        Token (Name "expression");
        Token (Literal ":");
        Token (Name "pattern");
      ];
      Token (Literal "...");
    |];
  );
  "metadata",
  Some (
    Repeat1 (
      Token (Name "annotation");
    );
  );
  "multiplicative_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "unary_expression");
        Repeat1 (
          Seq [
            Token (Name "multiplicative_operator");
            Token (Name "unary_expression");
          ];
        );
      ];
      Seq [
        Token (Name "super");
        Repeat1 (
          Seq [
            Token (Name "multiplicative_operator");
            Token (Name "unary_expression");
          ];
        );
      ];
    |];
  );
  "named_argument",
  Some (
    Seq [
      Token (Name "label");
      Token (Name "expression");
    ];
  );
  "named_formal_parameters",
  Some (
    Seq [
      Token (Literal "{");
      Token (Name "default_named_parameter");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "default_named_parameter");
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "}");
    ];
  );
  "named_parameter_type",
  Some (
    Seq [
      Opt (
        Token (Name "metadata");
      );
      Opt (
        Token (Name "required");
      );
      Token (Name "typed_identifier");
    ];
  );
  "named_parameter_types",
  Some (
    Seq [
      Token (Literal "{");
      Token (Name "named_parameter_type");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "named_parameter_type");
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "}");
    ];
  );
  "native",
  Some (
    Seq [
      Token (Literal "native");
      Opt (
        Token (Name "string_literal");
      );
    ];
  );
  "new_expression",
  Some (
    Seq [
      Token (Name "new_builtin");
      Token (Name "type_not_void");
      Opt (
        Token (Name "dot_identifier");
      );
      Token (Name "arguments");
    ];
  );
  "normal_formal_parameter",
  Some (
    Seq [
      Opt (
        Token (Name "metadata");
      );
      Alt [|
        Token (Name "function_formal_parameter");
        Token (Name "simple_formal_parameter");
        Token (Name "constructor_param");
        Token (Name "super_formal_parameter");
      |];
    ];
  );
  "normal_formal_parameters",
  Some (
    Seq [
      Token (Name "formal_parameter");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "formal_parameter");
        ];
      );
    ];
  );
  "normal_parameter_type",
  Some (
    Seq [
      Opt (
        Token (Name "metadata");
      );
      Alt [|
        Token (Name "typed_identifier");
        Token (Name "type");
      |];
    ];
  );
  "null_assert_pattern",
  Some (
    Seq [
      Token (Name "primary_pattern");
      Token (Literal "!");
    ];
  );
  "null_check_pattern",
  Some (
    Seq [
      Token (Name "primary_pattern");
      Token (Literal "?");
    ];
  );
  "object_pattern",
  Some (
    Seq [
      Token (Name "type_name");
      Opt (
        Token (Name "type_arguments");
      );
      Token (Literal "(");
      Token (Name "pattern_field");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "pattern_field");
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal ")");
    ];
  );
  "on_part",
  Some (
    Alt [|
      Seq [
        Token (Name "catch_clause");
        Token (Name "block");
      ];
      Seq [
        Token (Literal "on");
        Token (Name "type_not_void");
        Opt (
          Token (Name "catch_clause");
        );
        Token (Name "block");
      ];
    |];
  );
  "optional_formal_parameters",
  Some (
    Alt [|
      Token (Name "optional_postional_formal_parameters");
      Token (Name "named_formal_parameters");
    |];
  );
  "optional_parameter_types",
  Some (
    Alt [|
      Token (Name "optional_positional_parameter_types");
      Token (Name "named_parameter_types");
    |];
  );
  "optional_positional_parameter_types",
  Some (
    Seq [
      Token (Literal "[");
      Token (Name "normal_parameter_type");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "normal_parameter_type");
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "]");
    ];
  );
  "optional_postional_formal_parameters",
  Some (
    Seq [
      Token (Literal "[");
      Token (Name "default_formal_parameter");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "default_formal_parameter");
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "]");
    ];
  );
  "outer_pattern",
  Some (
    Alt [|
      Token (Name "parenthesized_pattern");
      Token (Name "list_pattern");
      Token (Name "map_pattern");
      Token (Name "record_pattern");
      Token (Name "object_pattern");
    |];
  );
  "pair",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal ":");
      Token (Name "expression");
    ];
  );
  "parameter_type_list",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Alt [|
          Seq [
            Token (Name "normal_parameter_type");
            Repeat (
              Seq [
                Token (Literal ",");
                Token (Name "normal_parameter_type");
              ];
            );
            Opt (
              Token (Literal ",");
            );
          ];
          Seq [
            Token (Name "normal_parameter_type");
            Repeat (
              Seq [
                Token (Literal ",");
                Token (Name "normal_parameter_type");
              ];
            );
            Token (Literal ",");
            Token (Name "optional_parameter_types");
          ];
          Token (Name "optional_parameter_types");
        |];
      );
      Token (Literal ")");
    ];
  );
  "parenthesized_expression",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
    ];
  );
  "parenthesized_pattern",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "pattern");
      Token (Literal ")");
    ];
  );
  "pattern",
  Some (
    Alt [|
      Token (Name "logical_or_pattern");
    |];
  );
  "pattern_assignment",
  Some (
    Seq [
      Token (Name "outer_pattern");
      Token (Literal "=");
      Token (Name "expression");
    ];
  );
  "pattern_field",
  Some (
    Seq [
      Opt (
        Seq [
          Opt (
            Token (Name "identifier");
          );
          Token (Literal ":");
        ];
      );
      Token (Name "pattern");
    ];
  );
  "pattern_variable_declaration",
  Some (
    Seq [
      Alt [|
        Token (Name "final_builtin");
        Token (Name "inferred_type");
      |];
      Token (Name "outer_pattern");
      Token (Literal "=");
      Token (Name "expression");
    ];
  );
  "postfix_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "primary");
        Repeat (
          Token (Name "selector");
        );
      ];
      Token (Name "postfix_expression_");
    |];
  );
  "postfix_expression_",
  Some (
    Alt [|
      Seq [
        Token (Name "assignable_expression");
        Token (Name "postfix_operator");
      ];
      Seq [
        Token (Name "constructor_invocation");
        Repeat (
          Token (Name "selector");
        );
      ];
    |];
  );
  "primary",
  Some (
    Alt [|
      Token (Name "literal");
      Token (Name "identifier");
      Token (Name "function_expression");
      Token (Name "new_expression");
      Token (Name "const_object_expression");
      Token (Name "parenthesized_expression");
      Token (Name "this");
      Seq [
        Token (Name "super");
        Token (Name "unconditional_assignable_selector");
      ];
      Token (Name "constructor_tearoff");
      Token (Name "switch_expression");
    |];
  );
  "primary_pattern",
  Some (
    Alt [|
      Token (Name "constant_pattern");
      Token (Name "variable_pattern");
      Token (Name "parenthesized_pattern");
      Token (Name "list_pattern");
      Token (Name "map_pattern");
      Token (Name "record_pattern");
      Token (Name "object_pattern");
    |];
  );
  "real_expression",
  Some (
    Alt [|
      Token (Name "conditional_expression");
      Token (Name "logical_or_expression");
      Token (Name "if_null_expression");
      Token (Name "additive_expression");
      Token (Name "multiplicative_expression");
      Token (Name "relational_expression");
      Token (Name "equality_expression");
      Token (Name "logical_and_expression");
      Token (Name "bitwise_and_expression");
      Token (Name "bitwise_or_expression");
      Token (Name "bitwise_xor_expression");
      Token (Name "shift_expression");
      Token (Name "type_cast_expression");
      Token (Name "type_test_expression");
      Token (Name "unary_expression");
    |];
  );
  "record_field",
  Some (
    Seq [
      Opt (
        Token (Name "label");
      );
      Token (Name "expression");
    ];
  );
  "record_literal",
  Some (
    Seq [
      Opt (
        Token (Name "const_builtin");
      );
      Token (Name "record_literal_no_const");
    ];
  );
  "record_literal_no_const",
  Some (
    Seq [
      Token (Literal "(");
      Alt [|
        Seq [
          Token (Name "label");
          Token (Name "expression");
        ];
        Seq [
          Token (Name "expression");
          Token (Literal ",");
        ];
        Seq [
          Token (Name "record_field");
          Repeat1 (
            Seq [
              Token (Literal ",");
              Token (Name "record_field");
            ];
          );
          Opt (
            Token (Literal ",");
          );
        ];
      |];
      Token (Literal ")");
    ];
  );
  "record_pattern",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "pattern_field");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "pattern_field");
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal ")");
    ];
  );
  "record_type",
  Some (
    Alt [|
      Seq [
        Token (Literal "(");
        Token (Literal ")");
      ];
      Seq [
        Token (Literal "(");
        Token (Name "record_type_field");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "record_type_field");
          ];
        );
        Token (Literal ",");
        Token (Literal "{");
        Token (Name "record_type_named_field");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "record_type_named_field");
          ];
        );
        Opt (
          Token (Literal ",");
        );
        Token (Literal "}");
        Token (Literal ")");
      ];
      Seq [
        Token (Literal "(");
        Token (Name "record_type_field");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "record_type_field");
          ];
        );
        Opt (
          Token (Literal ",");
        );
        Token (Literal ")");
      ];
      Seq [
        Token (Literal "(");
        Token (Literal "{");
        Token (Name "record_type_named_field");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "record_type_named_field");
          ];
        );
        Opt (
          Token (Literal ",");
        );
        Token (Literal "}");
        Token (Literal ")");
      ];
    |];
  );
  "record_type_field",
  Some (
    Seq [
      Opt (
        Token (Name "metadata");
      );
      Token (Name "type");
      Opt (
        Token (Name "identifier");
      );
    ];
  );
  "record_type_named_field",
  Some (
    Seq [
      Opt (
        Token (Name "metadata");
      );
      Token (Name "typed_identifier");
    ];
  );
  "relational_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "real_expression");
        Token (Name "relational_operator");
        Token (Name "real_expression");
      ];
      Seq [
        Token (Name "super");
        Token (Name "relational_operator");
        Token (Name "real_expression");
      ];
    |];
  );
  "relational_pattern",
  Some (
    Alt [|
      Seq [
        Alt [|
          Token (Name "relational_operator");
          Token (Name "equality_operator");
        |];
        Token (Name "real_expression");
      ];
      Token (Name "unary_pattern");
    |];
  );
  "rest_pattern",
  Some (
    Seq [
      Token (Literal "...");
      Opt (
        Token (Name "pattern");
      );
    ];
  );
  "return_statement",
  Some (
    Seq [
      Token (Literal "return");
      Opt (
        Token (Name "expression");
      );
      Token (Name "semicolon");
    ];
  );
  "selector",
  Some (
    Alt [|
      Token (Name "exclamation_operator");
      Token (Name "assignable_selector");
      Token (Name "argument_part");
      Token (Name "type_arguments");
    |];
  );
  "set_or_map_literal",
  Some (
    Seq [
      Opt (
        Token (Name "const_builtin");
      );
      Opt (
        Token (Name "type_arguments");
      );
      Token (Literal "{");
      Opt (
        Seq [
          Token (Name "element");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "element");
            ];
          );
          Opt (
            Token (Literal ",");
          );
        ];
      );
      Token (Literal "}");
    ];
  );
  "shift_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "real_expression");
        Repeat1 (
          Seq [
            Token (Name "shift_operator");
            Token (Name "real_expression");
          ];
        );
      ];
      Seq [
        Token (Name "super");
        Repeat1 (
          Seq [
            Token (Name "shift_operator");
            Token (Name "real_expression");
          ];
        );
      ];
    |];
  );
  "simple_formal_parameter",
  Some (
    Alt [|
      Token (Name "declared_identifier");
      Seq [
        Opt (
          Token (Name "covariant");
        );
        Token (Name "identifier");
      ];
    |];
  );
  "spread_element",
  Some (
    Seq [
      Token (Literal "...");
      Opt (
        Token (Literal "?");
      );
      Token (Name "expression");
    ];
  );
  "statement",
  Some (
    Alt [|
      Token (Name "block");
      Token (Name "local_function_declaration");
      Token (Name "local_variable_declaration");
      Token (Name "for_statement");
      Token (Name "while_statement");
      Token (Name "do_statement");
      Token (Name "switch_statement");
      Token (Name "if_statement");
      Token (Name "try_statement");
      Token (Name "break_statement");
      Token (Name "continue_statement");
      Token (Name "return_statement");
      Token (Name "yield_statement");
      Token (Name "yield_each_statement");
      Token (Name "expression_statement");
      Token (Name "assert_statement");
    |];
  );
  "strict_formal_parameter_list",
  Some (
    Alt [|
      Seq [
        Token (Literal "(");
        Token (Literal ")");
      ];
      Seq [
        Token (Literal "(");
        Token (Name "normal_formal_parameters");
        Opt (
          Token (Literal ",");
        );
        Token (Literal ")");
      ];
      Seq [
        Token (Literal "(");
        Token (Name "normal_formal_parameters");
        Token (Literal ",");
        Token (Name "optional_formal_parameters");
        Token (Literal ")");
      ];
      Seq [
        Token (Literal "(");
        Token (Name "optional_formal_parameters");
        Token (Literal ")");
      ];
    |];
  );
  "string_literal",
  Some (
    Repeat1 (
      Alt [|
        Token (Name "string_literal_double_quotes");
        Token (Name "string_literal_single_quotes");
        Token (Name "string_literal_double_quotes_multiple");
        Token (Name "string_literal_single_quotes_multiple");
        Token (Name "raw_string_literal_double_quotes");
        Token (Name "raw_string_literal_single_quotes");
        Token (Name "raw_string_literal_double_quotes_multiple");
        Token (Name "raw_string_literal_single_quotes_multiple");
      |];
    );
  );
  "string_literal_double_quotes",
  Some (
    Seq [
      Token (Literal "\"");
      Repeat (
        Alt [|
          Token (Name "template_chars_double_single");
          Token (Literal "'");
          Token (Name "escape_sequence");
          Token (Name "sub_string_test");
          Token (Name "template_substitution");
        |];
      );
      Token (Literal "\"");
    ];
  );
  "string_literal_double_quotes_multiple",
  Some (
    Seq [
      Token (Literal "\"\"\"");
      Repeat (
        Alt [|
          Token (Name "template_chars_double");
          Token (Literal "'");
          Token (Literal "\"");
          Token (Name "escape_sequence");
          Token (Name "sub_string_test");
          Token (Name "template_substitution");
        |];
      );
      Token (Literal "\"\"\"");
    ];
  );
  "string_literal_single_quotes",
  Some (
    Seq [
      Token (Literal "'");
      Repeat (
        Alt [|
          Token (Name "template_chars_single_single");
          Token (Literal "\"");
          Token (Name "escape_sequence");
          Token (Name "sub_string_test");
          Token (Name "template_substitution");
        |];
      );
      Token (Literal "'");
    ];
  );
  "string_literal_single_quotes_multiple",
  Some (
    Seq [
      Token (Literal "'''");
      Repeat (
        Alt [|
          Token (Name "template_chars_single");
          Token (Literal "\"");
          Token (Literal "'");
          Token (Name "escape_sequence");
          Token (Name "sub_string_test");
          Token (Name "template_substitution");
        |];
      );
      Token (Literal "'''");
    ];
  );
  "super_formal_parameter",
  Some (
    Seq [
      Opt (
        Token (Name "final_const_var_or_type");
      );
      Token (Name "super");
      Token (Literal ".");
      Token (Name "identifier");
      Opt (
        Token (Name "formal_parameter_part");
      );
    ];
  );
  "switch_block",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Token (Name "switch_statement_case");
      );
      Opt (
        Token (Name "switch_statement_default");
      );
      Token (Literal "}");
    ];
  );
  "switch_expression",
  Some (
    Seq [
      Token (Literal "switch");
      Token (Name "parenthesized_expression");
      Token (Literal "{");
      Token (Name "switch_expression_case");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "switch_expression_case");
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "}");
    ];
  );
  "switch_expression_case",
  Some (
    Seq [
      Token (Name "guarded_pattern");
      Token (Literal "=>");
      Token (Name "expression");
    ];
  );
  "switch_statement",
  Some (
    Seq [
      Token (Literal "switch");
      Token (Name "parenthesized_expression");
      Token (Name "switch_block");
    ];
  );
  "switch_statement_case",
  Some (
    Seq [
      Repeat (
        Token (Name "label");
      );
      Token (Name "case_builtin");
      Token (Name "guarded_pattern");
      Token (Literal ":");
      Repeat (
        Token (Name "statement");
      );
    ];
  );
  "switch_statement_default",
  Some (
    Seq [
      Repeat (
        Token (Name "label");
      );
      Token (Literal "default");
      Token (Literal ":");
      Repeat (
        Token (Name "statement");
      );
    ];
  );
  "template_substitution",
  Some (
    Seq [
      Token (Literal "$");
      Alt [|
        Seq [
          Token (Literal "{");
          Token (Name "expression");
          Token (Literal "}");
        ];
        Token (Name "identifier_dollar_escaped");
      |];
    ];
  );
  "throw_expression",
  Some (
    Seq [
      Token (Literal "throw");
      Token (Name "expression");
    ];
  );
  "throw_expression_without_cascade",
  Some (
    Seq [
      Token (Literal "throw");
      Token (Name "expression_without_cascade");
    ];
  );
  "try_head",
  Some (
    Seq [
      Token (Literal "try");
      Token (Name "block");
    ];
  );
  "try_statement",
  Some (
    Seq [
      Token (Name "try_head");
      Opt (
        Alt [|
          Token (Name "finally_clause");
          Seq [
            Repeat1 (
              Token (Name "on_part");
            );
            Opt (
              Token (Name "finally_clause");
            );
          ];
        |];
      );
    ];
  );
  "type",
  Some (
    Alt [|
      Seq [
        Token (Name "function_type");
        Opt (
          Token (Name "nullable_type");
        );
      ];
      Token (Name "type_not_function");
    |];
  );
  "type_arguments",
  Some (
    Alt [|
      Seq [
        Token (Literal "<");
        Opt (
          Seq [
            Token (Name "type");
            Repeat (
              Seq [
                Token (Literal ",");
                Token (Name "type");
              ];
            );
          ];
        );
        Token (Literal ">");
      ];
    |];
  );
  "type_bound",
  Some (
    Seq [
      Token (Literal "extends");
      Token (Name "type_not_void");
    ];
  );
  "type_cast",
  Some (
    Seq [
      Token (Name "as_operator");
      Token (Name "type_not_void");
    ];
  );
  "type_cast_expression",
  Some (
    Seq [
      Token (Name "real_expression");
      Token (Name "type_cast");
    ];
  );
  "type_not_function",
  Some (
    Alt [|
      Token (Name "type_not_void_not_function");
      Seq [
        Token (Name "record_type");
        Opt (
          Token (Name "nullable_type");
        );
      ];
      Token (Name "void_type");
    |];
  );
  "type_not_void",
  Some (
    Alt [|
      Seq [
        Token (Name "function_type");
        Opt (
          Token (Name "nullable_type");
        );
      ];
      Seq [
        Token (Name "record_type");
        Opt (
          Token (Name "nullable_type");
        );
      ];
      Token (Name "type_not_void_not_function");
    |];
  );
  "type_not_void_not_function",
  Some (
    Alt [|
      Seq [
        Token (Name "type_name");
        Opt (
          Token (Name "type_arguments");
        );
        Opt (
          Token (Name "nullable_type");
        );
      ];
      Seq [
        Token (Name "function_builtin_identifier");
        Opt (
          Token (Name "nullable_type");
        );
      ];
    |];
  );
  "type_parameter",
  Some (
    Seq [
      Opt (
        Token (Name "metadata");
      );
      Alt [|
        Token (Name "identifier");
        Token (Name "nullable_type");
      |];
      Opt (
        Token (Name "nullable_type");
      );
      Opt (
        Token (Name "type_bound");
      );
    ];
  );
  "type_parameters",
  Some (
    Seq [
      Token (Literal "<");
      Token (Name "type_parameter");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "type_parameter");
        ];
      );
      Token (Literal ">");
    ];
  );
  "type_test",
  Some (
    Seq [
      Token (Name "is_operator");
      Token (Name "type_not_void");
    ];
  );
  "type_test_expression",
  Some (
    Seq [
      Token (Name "real_expression");
      Token (Name "type_test");
    ];
  );
  "typed_identifier",
  Some (
    Seq [
      Token (Name "type");
      Token (Name "identifier");
    ];
  );
  "unary_expression",
  Some (
    Alt [|
      Token (Name "postfix_expression");
      Token (Name "unary_expression_");
    |];
  );
  "unary_expression_",
  Some (
    Alt [|
      Seq [
        Token (Name "prefix_operator");
        Token (Name "unary_expression");
      ];
      Token (Name "await_expression");
      Seq [
        Alt [|
          Token (Name "minus_operator");
          Token (Name "tilde_operator");
        |];
        Token (Name "super");
      ];
      Seq [
        Token (Name "increment_operator");
        Token (Name "assignable_expression");
      ];
    |];
  );
  "unary_pattern",
  Some (
    Alt [|
      Token (Name "cast_pattern");
      Token (Name "null_check_pattern");
      Token (Name "null_assert_pattern");
      Token (Name "primary_pattern");
    |];
  );
  "unconditional_assignable_selector",
  Some (
    Alt [|
      Token (Name "index_selector");
      Seq [
        Token (Literal ".");
        Token (Name "identifier");
      ];
    |];
  );
  "var_or_type",
  Some (
    Alt [|
      Token (Name "type");
      Seq [
        Token (Name "inferred_type");
        Opt (
          Token (Name "type");
        );
      ];
    |];
  );
  "variable_pattern",
  Some (
    Seq [
      Token (Name "final_var_or_type");
      Token (Name "identifier");
    ];
  );
  "while_statement",
  Some (
    Seq [
      Token (Literal "while");
      Token (Name "parenthesized_expression");
      Token (Name "statement");
    ];
  );
  "yield_each_statement",
  Some (
    Seq [
      Token (Literal "yield");
      Token (Literal "*");
      Token (Name "expression");
      Token (Name "semicolon");
    ];
  );
  "yield_statement",
  Some (
    Seq [
      Token (Literal "yield");
      Token (Name "expression");
      Token (Name "semicolon");
    ];
  );
  "enum_constant",
  Some (
    Alt [|
      Seq [
        Opt (
          Token (Name "metadata");
        );
        Token (Name "identifier");
        Opt (
          Token (Name "argument_part");
        );
      ];
      Seq [
        Opt (
          Token (Name "metadata");
        );
        Token (Name "identifier");
        Opt (
          Token (Name "type_arguments");
        );
        Token (Literal ".");
        Alt [|
          Token (Name "identifier");
          Token (Name "new_builtin");
        |];
        Token (Name "arguments");
      ];
    |];
  );
  "operator_signature",
  Some (
    Seq [
      Opt (
        Token (Name "type");
      );
      Token (Name "operator");
      Alt [|
        Token (Literal "~");
        Token (Name "binary_operator");
        Token (Literal "[]");
        Token (Literal "[]=");
      |];
      Token (Name "formal_parameter_list");
      Opt (
        Token (Name "native");
      );
    ];
  );
  "redirection",
  Some (
    Seq [
      Token (Literal ":");
      Token (Name "this");
      Opt (
        Seq [
          Token (Literal ".");
          Token (Name "identifier_or_new");
        ];
      );
      Token (Name "arguments");
    ];
  );
  "library_name",
  Some (
    Seq [
      Opt (
        Token (Name "metadata");
      );
      Token (Literal "library");
      Token (Name "dotted_identifier_list");
      Token (Name "semicolon");
    ];
  );
  "static_final_declaration",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Literal "=");
      Token (Name "expression");
    ];
  );
  "redirecting_factory_constructor_signature",
  Some (
    Seq [
      Opt (
        Token (Name "const_builtin");
      );
      Token (Name "factory");
      Token (Name "identifier");
      Repeat (
        Seq [
          Token (Literal ".");
          Token (Name "identifier");
        ];
      );
      Token (Name "formal_parameter_list");
      Token (Literal "=");
      Token (Name "type_not_void");
      Opt (
        Seq [
          Token (Literal ".");
          Token (Name "identifier");
        ];
      );
    ];
  );
  "uri", Some (Token (Name "string_literal"););
  "constructor_signature",
  Some (
    Seq [
      Token (Name "identifier");
      Opt (
        Seq [
          Token (Literal ".");
          Token (Name "identifier_or_new");
        ];
      );
      Token (Name "formal_parameter_list");
    ];
  );
  "setter_signature",
  Some (
    Seq [
      Opt (
        Token (Name "type");
      );
      Token (Name "set");
      Token (Name "identifier");
      Token (Name "formal_parameter_part");
      Opt (
        Token (Name "native");
      );
    ];
  );
  "field_initializer",
  Some (
    Seq [
      Opt (
        Seq [
          Token (Name "this");
          Token (Literal ".");
        ];
      );
      Token (Name "identifier");
      Token (Literal "=");
      Token (Name "real_expression");
      Repeat (
        Token (Name "cascade_section");
      );
    ];
  );
  "type_not_void_list",
  Some (
    Seq [
      Token (Name "type_not_void");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "type_not_void");
        ];
      );
    ];
  );
  "constant_constructor_signature",
  Some (
    Seq [
      Token (Name "const_builtin");
      Token (Name "identifier");
      Opt (
        Seq [
          Token (Literal ".");
          Token (Name "identifier_or_new");
        ];
      );
      Token (Name "formal_parameter_list");
    ];
  );
  "factory_constructor_signature",
  Some (
    Seq [
      Token (Name "factory");
      Token (Name "identifier");
      Repeat (
        Seq [
          Token (Literal ".");
          Token (Name "identifier");
        ];
      );
      Token (Name "formal_parameter_list");
    ];
  );
  "uri_test",
  Some (
    Seq [
      Token (Name "dotted_identifier_list");
      Opt (
        Seq [
          Token (Literal "==");
          Token (Name "string_literal");
        ];
      );
    ];
  );
  "getter_signature",
  Some (
    Seq [
      Opt (
        Token (Name "type");
      );
      Token (Name "get");
      Token (Name "identifier");
      Opt (
        Token (Name "native");
      );
    ];
  );
  "type_alias",
  Some (
    Alt [|
      Seq [
        Opt (
          Token (Name "metadata");
        );
        Token (Name "typedef");
        Opt (
          Token (Name "type");
        );
        Token (Name "type_name");
        Token (Name "formal_parameter_part");
        Token (Literal ";");
      ];
      Seq [
        Opt (
          Token (Name "metadata");
        );
        Token (Name "typedef");
        Token (Name "type_name");
        Opt (
          Token (Name "type_parameters");
        );
        Token (Literal "=");
        Token (Name "type");
        Token (Literal ";");
      ];
    |];
  );
  "semgrep_pattern",
  Some (
    Alt [|
      Token (Name "expression");
      Token (Name "statement");
    |];
  );
  "initialized_identifier_list",
  Some (
    Seq [
      Token (Name "initialized_identifier");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "initialized_identifier");
        ];
      );
    ];
  );
  "static_final_declaration_list",
  Some (
    Seq [
      Token (Name "static_final_declaration");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "static_final_declaration");
        ];
      );
    ];
  );
  "part_of_directive",
  Some (
    Seq [
      Opt (
        Token (Name "metadata");
      );
      Token (Name "part_of_builtin");
      Alt [|
        Token (Name "dotted_identifier_list");
        Token (Name "uri");
      |];
      Token (Name "semicolon");
    ];
  );
  "part_directive",
  Some (
    Seq [
      Opt (
        Token (Name "metadata");
      );
      Token (Literal "part");
      Token (Name "uri");
      Token (Name "semicolon");
    ];
  );
  "initializer_list_entry",
  Some (
    Alt [|
      Seq [
        Token (Name "super");
        Token (Name "arguments");
      ];
      Seq [
        Token (Name "super");
        Token (Literal ".");
        Alt [|
          Token (Name "identifier");
          Token (Name "new_builtin");
        |];
        Token (Name "arguments");
      ];
      Token (Name "field_initializer");
      Token (Name "assertion");
    |];
  );
  "mixins",
  Some (
    Seq [
      Token (Literal "with");
      Token (Name "type_not_void_list");
    ];
  );
  "interfaces",
  Some (
    Seq [
      Token (Name "implements");
      Token (Name "type_not_void_list");
    ];
  );
  "configuration_uri_condition",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "uri_test");
      Token (Literal ")");
    ];
  );
  "semgrep_expression",
  Some (
    Seq [
      Token (Literal "__SEMGREP_EXPRESSION");
      Token (Name "semgrep_pattern");
    ];
  );
  "initializers",
  Some (
    Seq [
      Token (Literal ":");
      Token (Name "initializer_list_entry");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "initializer_list_entry");
        ];
      );
    ];
  );
  "superclass",
  Some (
    Alt [|
      Seq [
        Token (Literal "extends");
        Token (Name "type_not_void");
        Opt (
          Token (Name "mixins");
        );
      ];
      Token (Name "mixins");
    |];
  );
  "mixin_application",
  Some (
    Seq [
      Token (Name "type_not_void");
      Token (Name "mixins");
      Opt (
        Token (Name "interfaces");
      );
    ];
  );
  "configuration_uri",
  Some (
    Seq [
      Token (Literal "if");
      Token (Name "configuration_uri_condition");
      Token (Name "uri");
    ];
  );
  "method_signature",
  Some (
    Alt [|
      Seq [
        Token (Name "constructor_signature");
        Opt (
          Token (Name "initializers");
        );
      ];
      Token (Name "factory_constructor_signature");
      Seq [
        Opt (
          Token (Name "static");
        );
        Alt [|
          Token (Name "function_signature");
          Token (Name "getter_signature");
          Token (Name "setter_signature");
        |];
      ];
      Token (Name "operator_signature");
    |];
  );
  "declaration_",
  Some (
    Alt [|
      Seq [
        Token (Name "constant_constructor_signature");
        Opt (
          Alt [|
            Token (Name "redirection");
            Token (Name "initializers");
          |];
        );
      ];
      Seq [
        Token (Name "constructor_signature");
        Opt (
          Alt [|
            Token (Name "redirection");
            Token (Name "initializers");
          |];
        );
      ];
      Seq [
        Token (Name "external");
        Opt (
          Token (Name "const_builtin");
        );
        Token (Name "factory_constructor_signature");
      ];
      Seq [
        Opt (
          Token (Name "const_builtin");
        );
        Token (Name "factory_constructor_signature");
        Token (Name "native");
      ];
      Seq [
        Token (Name "external");
        Token (Name "constant_constructor_signature");
      ];
      Token (Name "redirecting_factory_constructor_signature");
      Seq [
        Token (Name "external");
        Token (Name "constructor_signature");
      ];
      Seq [
        Opt (
          Token (Name "external_builtin");
        );
        Opt (
          Token (Name "static");
        );
        Token (Name "getter_signature");
      ];
      Seq [
        Opt (
          Token (Name "external_and_static");
        );
        Token (Name "setter_signature");
      ];
      Seq [
        Opt (
          Token (Name "external");
        );
        Token (Name "operator_signature");
      ];
      Seq [
        Opt (
          Token (Name "external_and_static");
        );
        Token (Name "function_signature");
      ];
      Seq [
        Token (Name "static");
        Token (Name "function_signature");
      ];
      Seq [
        Token (Name "static");
        Alt [|
          Seq [
            Token (Name "final_or_const");
            Opt (
              Token (Name "type");
            );
            Token (Name "static_final_declaration_list");
          ];
          Seq [
            Token (Name "late_builtin");
            Alt [|
              Seq [
                Token (Name "final_builtin");
                Opt (
                  Token (Name "type");
                );
                Token (Name "initialized_identifier_list");
              ];
              Seq [
                Alt [|
                  Token (Name "type");
                  Token (Name "inferred_type");
                |];
                Token (Name "initialized_identifier_list");
              ];
            |];
          ];
          Seq [
            Alt [|
              Token (Name "type");
              Token (Name "inferred_type");
            |];
            Token (Name "initialized_identifier_list");
          ];
        |];
      ];
      Seq [
        Token (Name "covariant");
        Alt [|
          Seq [
            Token (Name "late_builtin");
            Alt [|
              Seq [
                Token (Name "final_builtin");
                Opt (
                  Token (Name "type");
                );
                Token (Name "identifier_list_");
              ];
              Seq [
                Alt [|
                  Token (Name "type");
                  Token (Name "inferred_type");
                |];
                Token (Name "initialized_identifier_list");
              ];
            |];
          ];
          Seq [
            Alt [|
              Token (Name "type");
              Token (Name "inferred_type");
            |];
            Token (Name "initialized_identifier_list");
          ];
        |];
      ];
      Seq [
        Opt (
          Token (Name "late_builtin");
        );
        Token (Name "final_builtin");
        Opt (
          Token (Name "type");
        );
        Token (Name "initialized_identifier_list");
      ];
      Seq [
        Opt (
          Token (Name "late_builtin");
        );
        Token (Name "var_or_type");
        Token (Name "initialized_identifier_list");
      ];
    |];
  );
  "mixin_application_class",
  Some (
    Seq [
      Token (Name "identifier");
      Opt (
        Token (Name "type_parameters");
      );
      Token (Literal "=");
      Token (Name "mixin_application");
      Token (Name "semicolon");
    ];
  );
  "configurable_uri",
  Some (
    Seq [
      Token (Name "uri");
      Repeat (
        Token (Name "configuration_uri");
      );
    ];
  );
  "class_body",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Seq [
          Opt (
            Token (Name "metadata");
          );
          Alt [|
            Seq [
              Token (Name "declaration_");
              Token (Name "semicolon");
            ];
            Seq [
              Token (Name "method_signature");
              Token (Name "function_body");
            ];
          |];
        ];
      );
      Token (Literal "}");
    ];
  );
  "enum_body",
  Some (
    Seq [
      Token (Literal "{");
      Token (Name "enum_constant");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "enum_constant");
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Opt (
        Seq [
          Token (Literal ";");
          Repeat (
            Seq [
              Opt (
                Token (Name "metadata");
              );
              Alt [|
                Seq [
                  Token (Name "declaration_");
                  Token (Name "semicolon");
                ];
                Seq [
                  Token (Name "method_signature");
                  Token (Name "function_body");
                ];
              |];
            ];
          );
        ];
      );
      Token (Literal "}");
    ];
  );
  "extension_body",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Alt [|
          Seq [
            Opt (
              Token (Name "metadata");
            );
            Token (Name "declaration_");
            Token (Name "semicolon");
          ];
          Seq [
            Opt (
              Token (Name "metadata");
            );
            Token (Name "method_signature");
            Token (Name "function_body");
          ];
        |];
      );
      Token (Literal "}");
    ];
  );
  "import_specification",
  Some (
    Alt [|
      Seq [
        Token (Name "import");
        Token (Name "configurable_uri");
        Opt (
          Seq [
            Token (Name "as");
            Token (Name "identifier");
          ];
        );
        Repeat (
          Token (Name "combinator");
        );
        Token (Name "semicolon");
      ];
      Seq [
        Token (Name "import");
        Token (Name "uri");
        Token (Name "deferred");
        Token (Name "as");
        Token (Name "identifier");
        Repeat (
          Token (Name "combinator");
        );
        Token (Name "semicolon");
      ];
    |];
  );
  "library_export",
  Some (
    Seq [
      Opt (
        Token (Name "metadata");
      );
      Token (Name "export");
      Token (Name "configurable_uri");
      Repeat (
        Token (Name "combinator");
      );
      Token (Name "semicolon");
    ];
  );
  "class_definition",
  Some (
    Alt [|
      Seq [
        Opt (
          Token (Name "metadata");
        );
        Alt [|
          Token (Name "class_modifiers");
          Token (Name "mixin_class_modifiers");
        |];
        Token (Name "identifier");
        Opt (
          Token (Name "type_parameters");
        );
        Opt (
          Token (Name "superclass");
        );
        Opt (
          Token (Name "interfaces");
        );
        Token (Name "class_body");
      ];
      Seq [
        Opt (
          Token (Name "metadata");
        );
        Token (Name "class_modifiers");
        Token (Name "mixin_application_class");
      ];
    |];
  );
  "mixin_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "metadata");
      );
      Opt (
        Token (Name "base");
      );
      Token (Name "mixin");
      Token (Name "identifier");
      Opt (
        Token (Name "type_parameters");
      );
      Opt (
        Seq [
          Token (Literal "on");
          Token (Name "type_not_void_list");
        ];
      );
      Opt (
        Token (Name "interfaces");
      );
      Token (Name "class_body");
    ];
  );
  "enum_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "metadata");
      );
      Token (Literal "enum");
      Token (Name "identifier");
      Opt (
        Token (Name "type_parameters");
      );
      Opt (
        Token (Name "mixins");
      );
      Opt (
        Token (Name "interfaces");
      );
      Token (Name "enum_body");
    ];
  );
  "extension_declaration",
  Some (
    Alt [|
      Seq [
        Opt (
          Token (Name "metadata");
        );
        Token (Literal "extension");
        Opt (
          Token (Name "identifier");
        );
        Opt (
          Token (Name "type_parameters");
        );
        Token (Literal "on");
        Token (Name "type");
        Token (Name "extension_body");
      ];
    |];
  );
  "library_import",
  Some (
    Seq [
      Opt (
        Token (Name "metadata");
      );
      Token (Name "import_specification");
    ];
  );
  "top_level_definition",
  Some (
    Alt [|
      Token (Name "class_definition");
      Token (Name "mixin_declaration");
      Token (Name "extension_declaration");
      Token (Name "enum_declaration");
      Token (Name "type_alias");
      Seq [
        Opt (
          Token (Name "metadata");
        );
        Opt (
          Token (Name "external_builtin");
        );
        Token (Name "function_signature");
        Token (Name "semicolon");
      ];
      Seq [
        Opt (
          Token (Name "metadata");
        );
        Opt (
          Token (Name "external_builtin");
        );
        Token (Name "getter_signature");
        Token (Name "semicolon");
      ];
      Seq [
        Opt (
          Token (Name "metadata");
        );
        Opt (
          Token (Name "external_builtin");
        );
        Token (Name "setter_signature");
        Token (Name "semicolon");
      ];
      Seq [
        Opt (
          Token (Name "metadata");
        );
        Token (Name "getter_signature");
        Token (Name "function_body");
      ];
      Seq [
        Opt (
          Token (Name "metadata");
        );
        Token (Name "setter_signature");
        Token (Name "function_body");
      ];
      Seq [
        Opt (
          Token (Name "metadata");
        );
        Token (Name "function_signature");
        Token (Name "function_body");
      ];
      Seq [
        Opt (
          Token (Name "metadata");
        );
        Alt [|
          Token (Name "final_builtin");
          Token (Name "const_builtin");
        |];
        Opt (
          Token (Name "type");
        );
        Token (Name "static_final_declaration_list");
        Token (Name "semicolon");
      ];
      Seq [
        Opt (
          Token (Name "metadata");
        );
        Token (Name "late_builtin");
        Token (Name "final_builtin");
        Opt (
          Token (Name "type");
        );
        Token (Name "initialized_identifier_list");
        Token (Name "semicolon");
      ];
      Seq [
        Opt (
          Token (Name "metadata");
        );
        Opt (
          Token (Name "late_builtin");
        );
        Alt [|
          Token (Name "type");
          Token (Name "inferred_type");
        |];
        Token (Name "initialized_identifier_list");
        Token (Name "semicolon");
      ];
    |];
  );
  "import_or_export",
  Some (
    Alt [|
      Token (Name "library_import");
      Token (Name "library_export");
    |];
  );
  "program",
  Some (
    Alt [|
      Seq [
        Opt (
          Token (Name "script_tag");
        );
        Opt (
          Token (Name "library_name");
        );
        Repeat (
          Token (Name "import_or_export");
        );
        Repeat (
          Token (Name "part_directive");
        );
        Repeat (
          Token (Name "part_of_directive");
        );
        Repeat (
          Token (Name "top_level_definition");
        );
      ];
      Token (Name "semgrep_expression");
    |];
  );
]


let trans_pat_a3d33dc ((kind, body) : mt) : CST.pat_a3d33dc =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_super ((kind, body) : mt) : CST.super =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_d6c261f ((kind, body) : mt) : CST.pat_d6c261f =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_typedef ((kind, body) : mt) : CST.typedef =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_logical_or_operator ((kind, body) : mt) : CST.logical_or_operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_unused_escape_sequence ((kind, body) : mt) : CST.unused_escape_sequence =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_logical_and_operator ((kind, body) : mt) : CST.logical_and_operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_mixin ((kind, body) : mt) : CST.mixin =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_block_comment ((kind, body) : mt) : CST.block_comment =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_import ((kind, body) : mt) : CST.import =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_exclamation_operator ((kind, body) : mt) : CST.exclamation_operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_bitwise_operator ((kind, body) : mt) : CST.bitwise_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `AMP (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `HAT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `BAR (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_semgrep_named_ellipsis ((kind, body) : mt) : CST.semgrep_named_ellipsis =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_assignment_operator ((kind, body) : mt) : CST.assignment_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `EQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `PLUSEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `DASHEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `STAREQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `SLASHEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `PERCEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `TILDESLASHEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `LTLTEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `GTGTEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `GTGTGTEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `AMPEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `HATEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `BAREQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `QMARKQMARKEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_equality_operator ((kind, body) : mt) : CST.equality_operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_part_of_builtin ((kind, body) : mt) : CST.part_of_builtin =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_nullable_type ((kind, body) : mt) : CST.nullable_type =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_implements ((kind, body) : mt) : CST.implements =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_4fd4a56 ((kind, body) : mt) : CST.pat_4fd4a56 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_static ((kind, body) : mt) : CST.static =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_additive_operator_ ((kind, body) : mt) : CST.additive_operator_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_identifier_dollar_escaped ((kind, body) : mt) : CST.identifier_dollar_escaped =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_final_builtin ((kind, body) : mt) : CST.final_builtin =
  match body with
  | Leaf v -> v
  | Children _ -> assert false



let trans_increment_operator ((kind, body) : mt) : CST.increment_operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_minus_operator ((kind, body) : mt) : CST.minus_operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_external_builtin ((kind, body) : mt) : CST.external_builtin =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_this ((kind, body) : mt) : CST.this =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_required ((kind, body) : mt) : CST.required =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_case_builtin ((kind, body) : mt) : CST.case_builtin =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_break_builtin ((kind, body) : mt) : CST.break_builtin =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_template_chars_double_single ((kind, body) : mt) : CST.template_chars_double_single =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_decimal_integer_literal ((kind, body) : mt) : CST.decimal_integer_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_nullable_selector ((kind, body) : mt) : CST.nullable_selector =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_void_type ((kind, body) : mt) : CST.void_type =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_as_operator ((kind, body) : mt) : CST.as_operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_set ((kind, body) : mt) : CST.set =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_relational_operator ((kind, body) : mt) : CST.relational_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `LT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `GT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `LTEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `GTEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_rethrow_builtin ((kind, body) : mt) : CST.rethrow_builtin =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_null_literal ((kind, body) : mt) : CST.null_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_semicolon ((kind, body) : mt) : CST.semicolon =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_covariant ((kind, body) : mt) : CST.covariant =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_shift_operator_ ((kind, body) : mt) : CST.shift_operator_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `LTLT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `GTGT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `GTGTGT (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_inferred_type ((kind, body) : mt) : CST.inferred_type =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_multiplicative_operator_ ((kind, body) : mt) : CST.multiplicative_operator_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `STAR (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `SLASH (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `PERC (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `TILDESLASH (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_export ((kind, body) : mt) : CST.export =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_true_ ((kind, body) : mt) : CST.true_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_template_chars_double ((kind, body) : mt) : CST.template_chars_double =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_hex_integer_literal ((kind, body) : mt) : CST.hex_integer_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_tilde_operator ((kind, body) : mt) : CST.tilde_operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_identifier ((kind, body) : mt) : CST.identifier =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_05bf793 ((kind, body) : mt) : CST.pat_05bf793 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_function_builtin_identifier ((kind, body) : mt) : CST.function_builtin_identifier =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_template_chars_raw_slash ((kind, body) : mt) : CST.template_chars_raw_slash =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_sealed ((kind, body) : mt) : CST.sealed =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_deferred ((kind, body) : mt) : CST.deferred =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_as_ ((kind, body) : mt) : CST.as_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_interface ((kind, body) : mt) : CST.interface =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_operator ((kind, body) : mt) : CST.operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_late_builtin ((kind, body) : mt) : CST.late_builtin =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_get ((kind, body) : mt) : CST.get =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_const_builtin ((kind, body) : mt) : CST.const_builtin =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_factory ((kind, body) : mt) : CST.factory =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_template_chars_single_single ((kind, body) : mt) : CST.template_chars_single_single =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_semgrep_ellipsis ((kind, body) : mt) : CST.semgrep_ellipsis =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_new_builtin ((kind, body) : mt) : CST.new_builtin =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_base ((kind, body) : mt) : CST.base =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_abstract ((kind, body) : mt) : CST.abstract =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_documentation_block_comment ((kind, body) : mt) : CST.documentation_block_comment =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_decimal_floating_point_literal ((kind, body) : mt) : CST.decimal_floating_point_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_false_ ((kind, body) : mt) : CST.false_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_assert_builtin ((kind, body) : mt) : CST.assert_builtin =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_template_chars_single ((kind, body) : mt) : CST.template_chars_single =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_pat_0017fb0 ((kind, body) : mt) : CST.pat_0017fb0 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_tok_is ((kind, body) : mt) : CST.tok_is =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_sub_string_test ((kind, body) : mt) : CST.sub_string_test =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_pat_a3d33dc (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_escape_sequence ((kind, body) : mt) : CST.escape_sequence =
  match body with
  | Children v ->
      trans_unused_escape_sequence (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_negation_operator ((kind, body) : mt) : CST.negation_operator =
  match body with
  | Children v ->
      trans_exclamation_operator (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_bitwise_operator_ ((kind, body) : mt) : CST.bitwise_operator_ =
  match body with
  | Children v ->
      trans_bitwise_operator (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_additive_operator ((kind, body) : mt) : CST.additive_operator =
  match body with
  | Children v ->
      trans_additive_operator_ (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_postfix_operator ((kind, body) : mt) : CST.postfix_operator =
  match body with
  | Children v ->
      trans_increment_operator (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_external_ ((kind, body) : mt) : CST.external_ =
  match body with
  | Children v ->
      trans_external_builtin (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_rethrow_expression ((kind, body) : mt) : CST.rethrow_expression =
  match body with
  | Children v ->
      trans_rethrow_builtin (Run.matcher_token v)
  | Leaf _ -> assert false


let trans_shift_operator ((kind, body) : mt) : CST.shift_operator =
  match body with
  | Children v ->
      trans_shift_operator_ (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_multiplicative_operator ((kind, body) : mt) : CST.multiplicative_operator =
  match body with
  | Children v ->
      trans_multiplicative_operator_ (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_break_statement ((kind, body) : mt) : CST.break_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_break_builtin (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_identifier (Run.matcher_token v))
              v1
            ,
            trans_semicolon (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_dotted_identifier_list ((kind, body) : mt) : CST.dotted_identifier_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_type_dot_identifier ((kind, body) : mt) : CST.type_dot_identifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_identifier_list_ ((kind, body) : mt) : CST.identifier_list_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_identifier_list ((kind, body) : mt) : CST.identifier_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_catch_parameters ((kind, body) : mt) : CST.catch_parameters =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_scoped_identifier ((kind, body) : mt) : CST.scoped_identifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Scoped_id (
                  trans_scoped_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_symbol_literal ((kind, body) : mt) : CST.symbol_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_dot_identifier ((kind, body) : mt) : CST.dot_identifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_continue_statement ((kind, body) : mt) : CST.continue_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_identifier (Run.matcher_token v))
              v1
            ,
            trans_semicolon (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_label ((kind, body) : mt) : CST.label =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_comment ((kind, body) : mt) : CST.comment =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Blk_comm (
            trans_block_comment (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `SLASHSLASH_pat_d6c261f (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_pat_d6c261f (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `SLASHSTAR_pat_05bf793_SLASH (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_pat_05bf793 (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_final_or_const ((kind, body) : mt) : CST.final_or_const =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Final_buil (
            trans_final_builtin (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Const_buil (
            trans_const_builtin (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_identifier_or_new ((kind, body) : mt) : CST.identifier_or_new =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `New_buil (
            trans_new_builtin (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_mixin_class_modifiers ((kind, body) : mt) : CST.mixin_class_modifiers =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_abstract (Run.matcher_token v))
              v0
            ,
            Run.opt
              (fun v -> trans_base (Run.matcher_token v))
              v1
            ,
            trans_mixin (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_class_modifiers ((kind, body) : mt) : CST.class_modifiers =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Sealed (
                  trans_sealed (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Opt_abst_opt_choice_base (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.opt
                          (fun v -> trans_abstract (Run.matcher_token v))
                          v0
                        ,
                        Run.opt
                          (fun v ->
                            (match v with
                            | Alt (0, v) ->
                                `Base (
                                  trans_base (Run.matcher_token v)
                                )
                            | Alt (1, v) ->
                                `Inte (
                                  trans_interface (Run.matcher_token v)
                                )
                            | Alt (2, v) ->
                                `Final (
                                  Run.trans_token (Run.matcher_token v)
                                )
                            | Alt (3, v) ->
                                `Inline (
                                  Run.trans_token (Run.matcher_token v)
                                )
                            | _ -> assert false
                            )
                          )
                          v1
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_documentation_comment ((kind, body) : mt) : CST.documentation_comment =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Docu_blk_comm (
            trans_documentation_block_comment (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `SLASHSLASHSLASH_pat_4fd4a56 (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_pat_4fd4a56 (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_numeric_literal ((kind, body) : mt) : CST.numeric_literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Deci_int_lit (
            trans_decimal_integer_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Deci_floa_point_lit (
            trans_decimal_floating_point_literal (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Hex_int_lit (
            trans_hex_integer_literal (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_bool_literal ((kind, body) : mt) : CST.bool_literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `True (
            trans_true_ (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `False (
            trans_false_ (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_script_tag ((kind, body) : mt) : CST.script_tag =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_pat_0017fb0 (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_is_operator ((kind, body) : mt) : CST.is_operator =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_tok_is (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_exclamation_operator (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_raw_string_literal_double_quotes_multiple ((kind, body) : mt) : CST.raw_string_literal_double_quotes_multiple =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Temp_chars_double (
                      trans_template_chars_double (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `SQUOT (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `Temp_chars_raw_slash (
                      trans_template_chars_raw_slash (Run.matcher_token v)
                    )
                | Alt (3, v) ->
                    `DQUOT (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (4, v) ->
                    `Unused_esc_seq (
                      trans_unused_escape_sequence (Run.matcher_token v)
                    )
                | Alt (5, v) ->
                    `Sub_str_test (
                      trans_sub_string_test (Run.matcher_token v)
                    )
                | Alt (6, v) ->
                    `DOLLAR (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_raw_string_literal_single_quotes ((kind, body) : mt) : CST.raw_string_literal_single_quotes =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Temp_chars_single_single (
                      trans_template_chars_single_single (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `DQUOT (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `Temp_chars_raw_slash (
                      trans_template_chars_raw_slash (Run.matcher_token v)
                    )
                | Alt (3, v) ->
                    `Unused_esc_seq (
                      trans_unused_escape_sequence (Run.matcher_token v)
                    )
                | Alt (4, v) ->
                    `Sub_str_test (
                      trans_sub_string_test (Run.matcher_token v)
                    )
                | Alt (5, v) ->
                    `DOLLAR (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_raw_string_literal_single_quotes_multiple ((kind, body) : mt) : CST.raw_string_literal_single_quotes_multiple =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Temp_chars_single (
                      trans_template_chars_single (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `DQUOT (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `SQUOT (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (3, v) ->
                    `Temp_chars_raw_slash (
                      trans_template_chars_raw_slash (Run.matcher_token v)
                    )
                | Alt (4, v) ->
                    `Unused_esc_seq (
                      trans_unused_escape_sequence (Run.matcher_token v)
                    )
                | Alt (5, v) ->
                    `Sub_str_test (
                      trans_sub_string_test (Run.matcher_token v)
                    )
                | Alt (6, v) ->
                    `DOLLAR (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_raw_string_literal_double_quotes ((kind, body) : mt) : CST.raw_string_literal_double_quotes =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Temp_chars_double_single (
                      trans_template_chars_double_single (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `SQUOT (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `Temp_chars_raw_slash (
                      trans_template_chars_raw_slash (Run.matcher_token v)
                    )
                | Alt (3, v) ->
                    `Unused_esc_seq (
                      trans_unused_escape_sequence (Run.matcher_token v)
                    )
                | Alt (4, v) ->
                    `Sub_str_test (
                      trans_sub_string_test (Run.matcher_token v)
                    )
                | Alt (5, v) ->
                    `DOLLAR (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_prefix_operator ((kind, body) : mt) : CST.prefix_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Minus_op (
            trans_minus_operator (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Nega_op (
            trans_negation_operator (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Tilde_op (
            trans_tilde_operator (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_external_and_static ((kind, body) : mt) : CST.external_and_static =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_external_ (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_static (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_binary_operator ((kind, body) : mt) : CST.binary_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Mult_op (
            trans_multiplicative_operator (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Addi_op (
            trans_additive_operator (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Shift_op (
            trans_shift_operator (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Rela_op (
            trans_relational_operator (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `EQEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Bitw_op_ (
            trans_bitwise_operator_ (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_type_name ((kind, body) : mt) : CST.type_name =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_dot_identifier (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_combinator ((kind, body) : mt) : CST.combinator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Show_id_list (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_identifier_list (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Hide_id_list (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_identifier_list (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_catch_clause ((kind, body) : mt) : CST.catch_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_catch_parameters (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_qualified ((kind, body) : mt) : CST.qualified =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Type_name_DOT_id_or_new (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_type_name (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_identifier_or_new (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Type_name_DOT_type_name_DOT_id_or_new (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  trans_type_name (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_type_name (Run.matcher_token v2),
                  Run.trans_token (Run.matcher_token v3),
                  trans_identifier_or_new (Run.matcher_token v4)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_additive_expression ((kind, body) : mt) : CST.additive_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Real_exp_rep1_addi_op_real_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_real_expression (Run.matcher_token v0),
                  Run.repeat1
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_additive_operator (Run.matcher_token v0),
                            trans_real_expression (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Super_rep1_addi_op_real_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_super (Run.matcher_token v0),
                  Run.repeat1
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_additive_operator (Run.matcher_token v0),
                            trans_real_expression (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_annotation ((kind, body) : mt) : CST.annotation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Scoped_id (
                  trans_scoped_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v2 with
            | Alt (0, v) ->
                `Opt_type_args_args (
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_type_arguments (Run.matcher_token v0),
                            trans_arguments (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v
                )
            | Alt (1, v) ->
                `Opt_args (
                  Run.opt
                    (fun v -> trans_arguments (Run.matcher_token v))
                    v
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_any_argument ((kind, body) : mt) : CST.any_argument =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Arg (
            trans_argument (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Named_arg (
            trans_named_argument (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_argument ((kind, body) : mt) : CST.argument =
  match body with
  | Children v ->
      trans_expression (Run.matcher_token v)
  | Leaf _ -> assert false

and trans_argument_list ((kind, body) : mt) : CST.argument_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_any_argument (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_any_argument (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_argument_part ((kind, body) : mt) : CST.argument_part =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v -> trans_type_arguments (Run.matcher_token v))
              v0
            ,
            trans_arguments (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_arguments ((kind, body) : mt) : CST.arguments =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_argument_list (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_assert_statement ((kind, body) : mt) : CST.assert_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_assertion (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_assertion ((kind, body) : mt) : CST.assertion =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_assert_builtin (Run.matcher_token v0),
            trans_assertion_arguments (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_assertion_arguments ((kind, body) : mt) : CST.assertion_arguments =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_assignable_expression ((kind, body) : mt) : CST.assignable_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Prim_assi_sele_part (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_primary (Run.matcher_token v0),
                  trans_assignable_selector_part (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Super_unco_assi_sele (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_super (Run.matcher_token v0),
                  trans_unconditional_assignable_selector (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Cons_invo_assi_sele_part (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_constructor_invocation (Run.matcher_token v0),
                  trans_assignable_selector_part (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_assignable_selector ((kind, body) : mt) : CST.assignable_selector =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Unco_assi_sele (
            trans_unconditional_assignable_selector (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Cond_assi_sele (
            trans_conditional_assignable_selector (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_assignable_selector_part ((kind, body) : mt) : CST.assignable_selector_part =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.repeat
              (fun v -> trans_selector (Run.matcher_token v))
              v0
            ,
            trans_assignable_selector (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_assignment_expression ((kind, body) : mt) : CST.assignment_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_assignable_expression (Run.matcher_token v0),
            trans_assignment_operator (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_assignment_expression_without_cascade ((kind, body) : mt) : CST.assignment_expression_without_cascade =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_assignable_expression (Run.matcher_token v0),
            trans_assignment_operator (Run.matcher_token v1),
            trans_expression_without_cascade (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_await_expression ((kind, body) : mt) : CST.await_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_unary_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_bitwise_and_expression ((kind, body) : mt) : CST.bitwise_and_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Real_exp_rep1_AMP_real_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_real_expression (Run.matcher_token v0),
                  Run.repeat1
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_real_expression (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Super_rep1_AMP_real_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_super (Run.matcher_token v0),
                  Run.repeat1
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_real_expression (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_bitwise_or_expression ((kind, body) : mt) : CST.bitwise_or_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Real_exp_rep1_BAR_real_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_real_expression (Run.matcher_token v0),
                  Run.repeat1
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_real_expression (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Super_rep1_BAR_real_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_super (Run.matcher_token v0),
                  Run.repeat1
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_real_expression (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_bitwise_xor_expression ((kind, body) : mt) : CST.bitwise_xor_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Real_exp_rep1_HAT_real_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_real_expression (Run.matcher_token v0),
                  Run.repeat1
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_real_expression (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Super_rep1_HAT_real_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_super (Run.matcher_token v0),
                  Run.repeat1
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_real_expression (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_block ((kind, body) : mt) : CST.block =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_statement (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_cascade_assignment_section ((kind, body) : mt) : CST.cascade_assignment_section =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_assignment_operator (Run.matcher_token v0),
            trans_expression_without_cascade (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_cascade_section ((kind, body) : mt) : CST.cascade_section =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `DOTDOT (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `QMARKDOTDOT (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_cascade_selector (Run.matcher_token v1),
            Run.repeat
              (fun v -> trans_argument_part (Run.matcher_token v))
              v2
            ,
            Run.repeat
              (fun v -> trans_cascade_subsection (Run.matcher_token v))
              v3
            ,
            Run.opt
              (fun v ->
                trans_cascade_assignment_section (Run.matcher_token v)
              )
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_cascade_selector ((kind, body) : mt) : CST.cascade_selector =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_null_sele_index_sele (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.opt
                    (fun v -> trans_nullable_selector (Run.matcher_token v))
                    v0
                  ,
                  trans_index_selector (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_cascade_subsection ((kind, body) : mt) : CST.cascade_subsection =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_assignable_selector (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_argument_part (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_cast_pattern ((kind, body) : mt) : CST.cast_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_primary_pattern (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_type_ (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_conditional_assignable_selector ((kind, body) : mt) : CST.conditional_assignable_selector =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `QMARKDOT_id (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_identifier (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `QMARK_index_sele (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_index_selector (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_conditional_expression ((kind, body) : mt) : CST.conditional_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_real_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression_without_cascade (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression_without_cascade (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_const_object_expression ((kind, body) : mt) : CST.const_object_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_const_builtin (Run.matcher_token v0),
            trans_type_not_void (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_dot_identifier (Run.matcher_token v))
              v2
            ,
            trans_arguments (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_constant_pattern ((kind, body) : mt) : CST.constant_pattern =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Bool_lit (
            trans_bool_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Null_lit (
            trans_null_literal (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Opt_minus_op_nume_lit (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.opt
                    (fun v -> trans_minus_operator (Run.matcher_token v))
                    v0
                  ,
                  trans_numeric_literal (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Str_lit (
            trans_string_literal (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Symb_lit (
            trans_symbol_literal (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Qual (
            trans_qualified (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Const_obj_exp (
            trans_const_object_expression (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Const_buil_opt_type_args_LBRACK_elem_rep_COMMA_elem_opt_COMMA_RBRACK (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5; v6] ->
                (
                  trans_const_builtin (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_type_arguments (Run.matcher_token v))
                    v1
                  ,
                  Run.trans_token (Run.matcher_token v2),
                  trans_element (Run.matcher_token v3),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_element (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v4
                  ,
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v5
                  ,
                  Run.trans_token (Run.matcher_token v6)
                )
            | _ -> assert false
            )
          )
      | Alt (9, v) ->
          `Const_buil_opt_type_args_LCURL_elem_rep_COMMA_elem_opt_COMMA_RCURL (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5; v6] ->
                (
                  trans_const_builtin (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_type_arguments (Run.matcher_token v))
                    v1
                  ,
                  Run.trans_token (Run.matcher_token v2),
                  trans_element (Run.matcher_token v3),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_element (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v4
                  ,
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v5
                  ,
                  Run.trans_token (Run.matcher_token v6)
                )
            | _ -> assert false
            )
          )
      | Alt (10, v) ->
          `Const_buil_LPAR_exp_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  trans_const_builtin (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2),
                  Run.trans_token (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_constructor_invocation ((kind, body) : mt) : CST.constructor_invocation =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Type_name_type_args_DOT_id_args (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  trans_type_name (Run.matcher_token v0),
                  trans_type_arguments (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2),
                  trans_identifier (Run.matcher_token v3),
                  trans_arguments (Run.matcher_token v4)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Type_name_DOT_new_buil_args (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  trans_type_name (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_new_builtin (Run.matcher_token v2),
                  trans_arguments (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_constructor_param ((kind, body) : mt) : CST.constructor_param =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.opt
              (fun v ->
                trans_final_const_var_or_type (Run.matcher_token v)
              )
              v0
            ,
            trans_this (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_identifier (Run.matcher_token v3),
            Run.opt
              (fun v -> trans_formal_parameter_part (Run.matcher_token v))
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_constructor_tearoff ((kind, body) : mt) : CST.constructor_tearoff =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_type_name (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_arguments (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            trans_new_builtin (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_declared_identifier ((kind, body) : mt) : CST.declared_identifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_metadata (Run.matcher_token v))
              v0
            ,
            Run.opt
              (fun v -> trans_covariant (Run.matcher_token v))
              v1
            ,
            trans_final_const_var_or_type (Run.matcher_token v2),
            trans_identifier (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_deep_ellipsis ((kind, body) : mt) : CST.deep_ellipsis =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_default_formal_parameter ((kind, body) : mt) : CST.default_formal_parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_formal_parameter (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_default_named_parameter ((kind, body) : mt) : CST.default_named_parameter =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_meta_opt_requ_formal_param_opt_EQ_exp (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.opt
                    (fun v -> trans_metadata (Run.matcher_token v))
                    v0
                  ,
                  Run.opt
                    (fun v -> trans_required (Run.matcher_token v))
                    v1
                  ,
                  trans_formal_parameter (Run.matcher_token v2),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_expression (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v3
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Opt_meta_opt_requ_formal_param_opt_COLON_exp (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.opt
                    (fun v -> trans_metadata (Run.matcher_token v))
                    v0
                  ,
                  Run.opt
                    (fun v -> trans_required (Run.matcher_token v))
                    v1
                  ,
                  trans_formal_parameter (Run.matcher_token v2),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_expression (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v3
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_do_statement ((kind, body) : mt) : CST.do_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_statement (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_parenthesized_expression (Run.matcher_token v3),
            trans_semicolon (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_element ((kind, body) : mt) : CST.element =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp (
            trans_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pair (
            trans_pair (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Spread_elem (
            trans_spread_element (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `If_elem (
            trans_if_element (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `For_elem (
            trans_for_element (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_equality_expression ((kind, body) : mt) : CST.equality_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Real_exp_equa_op_real_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_real_expression (Run.matcher_token v0),
                  trans_equality_operator (Run.matcher_token v1),
                  trans_real_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Super_equa_op_real_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_super (Run.matcher_token v0),
                  trans_equality_operator (Run.matcher_token v1),
                  trans_real_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expression ((kind, body) : mt) : CST.expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_pat_assign (
            (match v with
            | Alt (0, v) ->
                `Pat_assign (
                  trans_pattern_assignment (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Assign_exp (
                  trans_assignment_expression (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Throw_exp (
                  trans_throw_expression (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Reth_exp (
                  trans_rethrow_expression (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `Real_exp_rep_casc_sect (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_real_expression (Run.matcher_token v0),
                        Run.repeat
                          (fun v -> trans_cascade_section (Run.matcher_token v))
                          v1
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Semg_ellips (
            trans_semgrep_ellipsis (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Semg_named_ellips (
            trans_semgrep_named_ellipsis (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Deep_ellips (
            trans_deep_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expression_statement ((kind, body) : mt) : CST.expression_statement =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp_semi (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_expression (Run.matcher_token v0),
                  trans_semicolon (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Semg_ellips (
            trans_semgrep_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expression_without_cascade ((kind, body) : mt) : CST.expression_without_cascade =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Assign_exp_with_casc (
            trans_assignment_expression_without_cascade (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Real_exp (
            trans_real_expression (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Throw_exp_with_casc (
            trans_throw_expression_without_cascade (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_final_const_var_or_type ((kind, body) : mt) : CST.final_const_var_or_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_late_buil_final_buil_opt_type (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.opt
                    (fun v -> trans_late_builtin (Run.matcher_token v))
                    v0
                  ,
                  trans_final_builtin (Run.matcher_token v1),
                  Run.opt
                    (fun v -> trans_type_ (Run.matcher_token v))
                    v2
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Const_buil_opt_type (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_const_builtin (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_type_ (Run.matcher_token v))
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Opt_late_buil_var_or_type (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.opt
                    (fun v -> trans_late_builtin (Run.matcher_token v))
                    v0
                  ,
                  trans_var_or_type (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_final_var_or_type ((kind, body) : mt) : CST.final_var_or_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Infe_type (
            trans_inferred_type (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Final_buil (
            trans_final_builtin (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Opt_final_buil_type (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.opt
                    (fun v -> trans_final_builtin (Run.matcher_token v))
                    v0
                  ,
                  trans_type_ (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_finally_clause ((kind, body) : mt) : CST.finally_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_block (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_element ((kind, body) : mt) : CST.for_element =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_for_loop_parts (Run.matcher_token v2),
            trans_element (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_loop_parts ((kind, body) : mt) : CST.for_loop_parts =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_for_loop_parts_ (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_loop_parts_ ((kind, body) : mt) : CST.for_loop_parts_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_decl_id_in_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  (match v0 with
                  | Alt (0, v) ->
                      `Decl_id (
                        trans_declared_identifier (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Id (
                        trans_identifier (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Opt_choice_local_var_decl_opt_exp_semi_opt_exp_rep_COMMA_exp (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.opt
                    (fun v ->
                      (match v with
                      | Alt (0, v) ->
                          `Local_var_decl (
                            trans_local_variable_declaration (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Opt_exp_rep_COMMA_exp_semi (
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.opt
                                    (fun v ->
                                      (match v with
                                      | Seq [v0; v1] ->
                                          (
                                            trans_expression (Run.matcher_token v0),
                                            Run.repeat
                                              (fun v ->
                                                (match v with
                                                | Seq [v0; v1] ->
                                                    (
                                                      Run.trans_token (Run.matcher_token v0),
                                                      trans_expression (Run.matcher_token v1)
                                                    )
                                                | _ -> assert false
                                                )
                                              )
                                              v1
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v0
                                  ,
                                  trans_semicolon (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                      | _ -> assert false
                      )
                    )
                    v0
                  ,
                  Run.opt
                    (fun v -> trans_expression (Run.matcher_token v))
                    v1
                  ,
                  trans_semicolon (Run.matcher_token v2),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_expression (Run.matcher_token v0),
                            Run.repeat
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      Run.trans_token (Run.matcher_token v0),
                                      trans_expression (Run.matcher_token v1)
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                          )
                      | _ -> assert false
                      )
                    )
                    v3
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Choice_final_buil_outer_pat_in_exp (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  (match v0 with
                  | Alt (0, v) ->
                      `Final_buil (
                        trans_final_builtin (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Infe_type (
                        trans_inferred_type (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_outer_pattern (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2),
                  trans_expression (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_statement ((kind, body) : mt) : CST.for_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_for_loop_parts (Run.matcher_token v2),
            trans_statement (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_formal_parameter ((kind, body) : mt) : CST.formal_parameter =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Semg_ellips (
            trans_semgrep_ellipsis (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Normal_formal_param (
            trans_normal_formal_parameter (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_formal_parameter_list ((kind, body) : mt) : CST.formal_parameter_list =
  match body with
  | Children v ->
      trans_strict_formal_parameter_list (Run.matcher_token v)
  | Leaf _ -> assert false

and trans_formal_parameter_part ((kind, body) : mt) : CST.formal_parameter_part =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v -> trans_type_parameters (Run.matcher_token v))
              v0
            ,
            trans_formal_parameter_list (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_body ((kind, body) : mt) : CST.function_body =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_async_EQGT_exp_semi (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v0
                  ,
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2),
                  trans_semicolon (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Opt_choice_async_blk (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.opt
                    (fun v ->
                      (match v with
                      | Alt (0, v) ->
                          `Async (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Asyn (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | Alt (2, v) ->
                          `Sync (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                    v0
                  ,
                  trans_block (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_expression ((kind, body) : mt) : CST.function_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_formal_parameter_part (Run.matcher_token v0),
            trans_function_expression_body (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_expression_body ((kind, body) : mt) : CST.function_expression_body =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_async_EQGT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v0
                  ,
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Opt_choice_async_blk (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.opt
                    (fun v ->
                      (match v with
                      | Alt (0, v) ->
                          `Async (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Asyn (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | Alt (2, v) ->
                          `Sync (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                    v0
                  ,
                  trans_block (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_formal_parameter ((kind, body) : mt) : CST.function_formal_parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.opt
              (fun v -> trans_covariant (Run.matcher_token v))
              v0
            ,
            Run.opt
              (fun v -> trans_type_ (Run.matcher_token v))
              v1
            ,
            trans_identifier (Run.matcher_token v2),
            trans_formal_parameter_part (Run.matcher_token v3),
            Run.opt
              (fun v -> trans_nullable_type (Run.matcher_token v))
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_signature ((kind, body) : mt) : CST.function_signature =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_type_ (Run.matcher_token v))
              v0
            ,
            (match v1 with
            | Alt (0, v) ->
                `Get (
                  trans_get (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Set (
                  trans_set (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_formal_parameter_part (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_native (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_type ((kind, body) : mt) : CST.function_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Func_type_tails (
            trans_function_type_tails (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Type_not_func_func_type_tails (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_type_not_function (Run.matcher_token v0),
                  trans_function_type_tails (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_type_tail ((kind, body) : mt) : CST.function_type_tail =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_function_builtin_identifier (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_parameters (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v -> trans_nullable_type (Run.matcher_token v))
              v2
            ,
            Run.opt
              (fun v -> trans_parameter_type_list (Run.matcher_token v))
              v3
            ,
            Run.opt
              (fun v -> trans_nullable_type (Run.matcher_token v))
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_type_tails ((kind, body) : mt) : CST.function_type_tails =
  match body with
  | Children v ->
      Run.repeat1
        (fun v -> trans_function_type_tail (Run.matcher_token v))
        v
  | Leaf _ -> assert false

and trans_guarded_pattern ((kind, body) : mt) : CST.guarded_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pattern (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_if_element ((kind, body) : mt) : CST.if_element =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_guarded_pattern (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.trans_token (Run.matcher_token v4),
            trans_element (Run.matcher_token v5),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_element (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v6
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_if_null_expression ((kind, body) : mt) : CST.if_null_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_real_expression (Run.matcher_token v0),
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_real_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_if_statement ((kind, body) : mt) : CST.if_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_guarded_pattern (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.trans_token (Run.matcher_token v4),
            trans_statement (Run.matcher_token v5),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_statement (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v6
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_index_selector ((kind, body) : mt) : CST.index_selector =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_initialized_identifier ((kind, body) : mt) : CST.initialized_identifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_initialized_variable_definition ((kind, body) : mt) : CST.initialized_variable_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_declared_identifier (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_initialized_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_lambda_expression ((kind, body) : mt) : CST.lambda_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_function_signature (Run.matcher_token v0),
            trans_function_body (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_list_literal ((kind, body) : mt) : CST.list_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.opt
              (fun v -> trans_const_builtin (Run.matcher_token v))
              v0
            ,
            Run.opt
              (fun v -> trans_type_arguments (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_element (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_element (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                      ,
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v2
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_list_pattern ((kind, body) : mt) : CST.list_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_type_arguments (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_list_pattern_element (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_list_pattern_element (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                      ,
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v2
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_list_pattern_element ((kind, body) : mt) : CST.list_pattern_element =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat (
            trans_pattern (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Rest_pat (
            trans_rest_pattern (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_literal ((kind, body) : mt) : CST.literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Null_lit (
            trans_null_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Bool_lit (
            trans_bool_literal (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Nume_lit (
            trans_numeric_literal (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Str_lit (
            trans_string_literal (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Symb_lit (
            trans_symbol_literal (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Set_or_map_lit (
            trans_set_or_map_literal (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `List_lit (
            trans_list_literal (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Record_lit (
            trans_record_literal (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_local_function_declaration ((kind, body) : mt) : CST.local_function_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v -> trans_metadata (Run.matcher_token v))
              v0
            ,
            trans_lambda_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_local_variable_declaration ((kind, body) : mt) : CST.local_variable_declaration =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_meta_init_var_defi_semi (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.opt
                    (fun v -> trans_metadata (Run.matcher_token v))
                    v0
                  ,
                  trans_initialized_variable_definition (Run.matcher_token v1)
                  ,
                  trans_semicolon (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Opt_meta_pat_var_decl_semi (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.opt
                    (fun v -> trans_metadata (Run.matcher_token v))
                    v0
                  ,
                  trans_pattern_variable_declaration (Run.matcher_token v1),
                  trans_semicolon (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_logical_and_expression ((kind, body) : mt) : CST.logical_and_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_real_expression (Run.matcher_token v0),
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_logical_and_operator (Run.matcher_token v0),
                      trans_real_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_logical_and_pattern ((kind, body) : mt) : CST.logical_and_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_relational_pattern (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_logical_and_operator (Run.matcher_token v0),
                      trans_relational_pattern (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_logical_or_expression ((kind, body) : mt) : CST.logical_or_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_real_expression (Run.matcher_token v0),
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_logical_or_operator (Run.matcher_token v0),
                      trans_real_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_logical_or_pattern ((kind, body) : mt) : CST.logical_or_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_logical_and_pattern (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_logical_or_operator (Run.matcher_token v0),
                      trans_logical_and_pattern (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_map_pattern ((kind, body) : mt) : CST.map_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_type_arguments (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_map_pattern_entry (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_map_pattern_entry (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                      ,
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v2
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_map_pattern_entry ((kind, body) : mt) : CST.map_pattern_entry =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp_COLON_pat (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_pattern (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `DOTDOTDOT (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_metadata ((kind, body) : mt) : CST.metadata =
  match body with
  | Children v ->
      Run.repeat1
        (fun v -> trans_annotation (Run.matcher_token v))
        v
  | Leaf _ -> assert false

and trans_multiplicative_expression ((kind, body) : mt) : CST.multiplicative_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Un_exp_rep1_mult_op_un_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_unary_expression (Run.matcher_token v0),
                  Run.repeat1
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_multiplicative_operator (Run.matcher_token v0),
                            trans_unary_expression (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Super_rep1_mult_op_un_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_super (Run.matcher_token v0),
                  Run.repeat1
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_multiplicative_operator (Run.matcher_token v0),
                            trans_unary_expression (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_named_argument ((kind, body) : mt) : CST.named_argument =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_label (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_named_formal_parameters ((kind, body) : mt) : CST.named_formal_parameters =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_default_named_parameter (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_default_named_parameter (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_named_parameter_type ((kind, body) : mt) : CST.named_parameter_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.opt
              (fun v -> trans_metadata (Run.matcher_token v))
              v0
            ,
            Run.opt
              (fun v -> trans_required (Run.matcher_token v))
              v1
            ,
            trans_typed_identifier (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_named_parameter_types ((kind, body) : mt) : CST.named_parameter_types =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_named_parameter_type (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_named_parameter_type (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_native ((kind, body) : mt) : CST.native =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_string_literal (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_new_expression ((kind, body) : mt) : CST.new_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_new_builtin (Run.matcher_token v0),
            trans_type_not_void (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_dot_identifier (Run.matcher_token v))
              v2
            ,
            trans_arguments (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_normal_formal_parameter ((kind, body) : mt) : CST.normal_formal_parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v -> trans_metadata (Run.matcher_token v))
              v0
            ,
            (match v1 with
            | Alt (0, v) ->
                `Func_formal_param (
                  trans_function_formal_parameter (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Simple_formal_param (
                  trans_simple_formal_parameter (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Cons_param (
                  trans_constructor_param (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Super_formal_param (
                  trans_super_formal_parameter (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_normal_formal_parameters ((kind, body) : mt) : CST.normal_formal_parameters =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_formal_parameter (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_formal_parameter (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_normal_parameter_type ((kind, body) : mt) : CST.normal_parameter_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v -> trans_metadata (Run.matcher_token v))
              v0
            ,
            (match v1 with
            | Alt (0, v) ->
                `Typed_id (
                  trans_typed_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Type (
                  trans_type_ (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_null_assert_pattern ((kind, body) : mt) : CST.null_assert_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_primary_pattern (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_null_check_pattern ((kind, body) : mt) : CST.null_check_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_primary_pattern (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_object_pattern ((kind, body) : mt) : CST.object_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            trans_type_name (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_arguments (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            trans_pattern_field (Run.matcher_token v3),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_pattern_field (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v4
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v5
            ,
            Run.trans_token (Run.matcher_token v6)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_on_part ((kind, body) : mt) : CST.on_part =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Catch_clause_blk (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_catch_clause (Run.matcher_token v0),
                  trans_block (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `On_type_not_void_opt_catch_clause_blk (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_type_not_void (Run.matcher_token v1),
                  Run.opt
                    (fun v -> trans_catch_clause (Run.matcher_token v))
                    v2
                  ,
                  trans_block (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_optional_formal_parameters ((kind, body) : mt) : CST.optional_formal_parameters =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_post_formal_params (
            trans_optional_postional_formal_parameters (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Named_formal_params (
            trans_named_formal_parameters (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_optional_parameter_types ((kind, body) : mt) : CST.optional_parameter_types =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_posi_param_types (
            trans_optional_positional_parameter_types (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Named_param_types (
            trans_named_parameter_types (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_optional_positional_parameter_types ((kind, body) : mt) : CST.optional_positional_parameter_types =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_normal_parameter_type (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_normal_parameter_type (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_optional_postional_formal_parameters ((kind, body) : mt) : CST.optional_postional_formal_parameters =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_default_formal_parameter (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_default_formal_parameter (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_outer_pattern ((kind, body) : mt) : CST.outer_pattern =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Paren_pat (
            trans_parenthesized_pattern (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `List_pat (
            trans_list_pattern (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Map_pat (
            trans_map_pattern (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Record_pat (
            trans_record_pattern (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Obj_pat (
            trans_object_pattern (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pair ((kind, body) : mt) : CST.pair =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parameter_type_list ((kind, body) : mt) : CST.parameter_type_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Normal_param_type_rep_COMMA_normal_param_type_opt_COMMA (
                      (match v with
                      | Seq [v0; v1; v2] ->
                          (
                            trans_normal_parameter_type (Run.matcher_token v0),
                            Run.repeat
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      Run.trans_token (Run.matcher_token v0),
                                      trans_normal_parameter_type (Run.matcher_token v1)
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                            ,
                            Run.opt
                              (fun v -> Run.trans_token (Run.matcher_token v))
                              v2
                          )
                      | _ -> assert false
                      )
                    )
                | Alt (1, v) ->
                    `Normal_param_type_rep_COMMA_normal_param_type_COMMA_opt_param_types (
                      (match v with
                      | Seq [v0; v1; v2; v3] ->
                          (
                            trans_normal_parameter_type (Run.matcher_token v0),
                            Run.repeat
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      Run.trans_token (Run.matcher_token v0),
                                      trans_normal_parameter_type (Run.matcher_token v1)
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                            ,
                            Run.trans_token (Run.matcher_token v2),
                            trans_optional_parameter_types (Run.matcher_token v3)
                          )
                      | _ -> assert false
                      )
                    )
                | Alt (2, v) ->
                    `Opt_param_types (
                      trans_optional_parameter_types (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parenthesized_expression ((kind, body) : mt) : CST.parenthesized_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parenthesized_pattern ((kind, body) : mt) : CST.parenthesized_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_pattern (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pattern ((kind, body) : mt) : CST.pattern =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Logi_or_pat (
            trans_logical_or_pattern (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pattern_assignment ((kind, body) : mt) : CST.pattern_assignment =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_outer_pattern (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pattern_field ((kind, body) : mt) : CST.pattern_field =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.opt
                        (fun v -> trans_identifier (Run.matcher_token v))
                        v0
                      ,
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            trans_pattern (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pattern_variable_declaration ((kind, body) : mt) : CST.pattern_variable_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Final_buil (
                  trans_final_builtin (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Infe_type (
                  trans_inferred_type (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_outer_pattern (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_expression (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_postfix_expression ((kind, body) : mt) : CST.postfix_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Prim_rep_sele (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_primary (Run.matcher_token v0),
                  Run.repeat
                    (fun v -> trans_selector (Run.matcher_token v))
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Post_exp_ (
            trans_postfix_expression_ (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_postfix_expression_ ((kind, body) : mt) : CST.postfix_expression_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Assi_exp_post_op (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_assignable_expression (Run.matcher_token v0),
                  trans_postfix_operator (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Cons_invo_rep_sele (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_constructor_invocation (Run.matcher_token v0),
                  Run.repeat
                    (fun v -> trans_selector (Run.matcher_token v))
                    v1
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_primary ((kind, body) : mt) : CST.primary =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Lit (
            trans_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Func_exp (
            trans_function_expression (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `New_exp (
            trans_new_expression (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Const_obj_exp (
            trans_const_object_expression (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Paren_exp (
            trans_parenthesized_expression (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `This (
            trans_this (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Super_unco_assi_sele (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_super (Run.matcher_token v0),
                  trans_unconditional_assignable_selector (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (8, v) ->
          `Cons_tear (
            trans_constructor_tearoff (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Switch_exp (
            trans_switch_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_primary_pattern ((kind, body) : mt) : CST.primary_pattern =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Cst_pat (
            trans_constant_pattern (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Var_pat (
            trans_variable_pattern (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Paren_pat (
            trans_parenthesized_pattern (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `List_pat (
            trans_list_pattern (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Map_pat (
            trans_map_pattern (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Record_pat (
            trans_record_pattern (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Obj_pat (
            trans_object_pattern (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_real_expression ((kind, body) : mt) : CST.real_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Cond_exp (
            trans_conditional_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Logi_or_exp (
            trans_logical_or_expression (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `If_null_exp (
            trans_if_null_expression (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Addi_exp (
            trans_additive_expression (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Mult_exp (
            trans_multiplicative_expression (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Rela_exp (
            trans_relational_expression (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Equa_exp (
            trans_equality_expression (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Logi_and_exp (
            trans_logical_and_expression (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Bitw_and_exp (
            trans_bitwise_and_expression (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Bitw_or_exp (
            trans_bitwise_or_expression (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Bitw_xor_exp (
            trans_bitwise_xor_expression (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Shift_exp (
            trans_shift_expression (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Type_cast_exp (
            trans_type_cast_expression (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Type_test_exp (
            trans_type_test_expression (Run.matcher_token v)
          )
      | Alt (14, v) ->
          `Un_exp (
            trans_unary_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_record_field ((kind, body) : mt) : CST.record_field =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v -> trans_label (Run.matcher_token v))
              v0
            ,
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_record_literal ((kind, body) : mt) : CST.record_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v -> trans_const_builtin (Run.matcher_token v))
              v0
            ,
            trans_record_literal_no_const (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_record_literal_no_const ((kind, body) : mt) : CST.record_literal_no_const =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Label_exp (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_label (Run.matcher_token v0),
                        trans_expression (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Exp_COMMA (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_expression (Run.matcher_token v0),
                        Run.trans_token (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Record_field_rep1_COMMA_record_field_opt_COMMA (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        trans_record_field (Run.matcher_token v0),
                        Run.repeat1
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  trans_record_field (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                          v1
                        ,
                        Run.opt
                          (fun v -> Run.trans_token (Run.matcher_token v))
                          v2
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_record_pattern ((kind, body) : mt) : CST.record_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_pattern_field (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_pattern_field (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_record_type ((kind, body) : mt) : CST.record_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `LPAR_RPAR (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `LPAR_record_type_field_rep_COMMA_record_type_field_COMMA_LCURL_record_type_named_field_rep_COMMA_record_type_named_field_opt_COMMA_RCURL_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5; v6; v7; v8; v9] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_record_type_field (Run.matcher_token v1),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_record_type_field (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v2
                  ,
                  Run.trans_token (Run.matcher_token v3),
                  Run.trans_token (Run.matcher_token v4),
                  trans_record_type_named_field (Run.matcher_token v5),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_record_type_named_field (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v6
                  ,
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v7
                  ,
                  Run.trans_token (Run.matcher_token v8),
                  Run.trans_token (Run.matcher_token v9)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `LPAR_record_type_field_rep_COMMA_record_type_field_opt_COMMA_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_record_type_field (Run.matcher_token v1),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_record_type_field (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v2
                  ,
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v3
                  ,
                  Run.trans_token (Run.matcher_token v4)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `LPAR_LCURL_record_type_named_field_rep_COMMA_record_type_named_field_opt_COMMA_RCURL_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5; v6] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_record_type_named_field (Run.matcher_token v2),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_record_type_named_field (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v3
                  ,
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v4
                  ,
                  Run.trans_token (Run.matcher_token v5),
                  Run.trans_token (Run.matcher_token v6)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_record_type_field ((kind, body) : mt) : CST.record_type_field =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.opt
              (fun v -> trans_metadata (Run.matcher_token v))
              v0
            ,
            trans_type_ (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_identifier (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_record_type_named_field ((kind, body) : mt) : CST.record_type_named_field =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v -> trans_metadata (Run.matcher_token v))
              v0
            ,
            trans_typed_identifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_relational_expression ((kind, body) : mt) : CST.relational_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Real_exp_rela_op_real_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_real_expression (Run.matcher_token v0),
                  trans_relational_operator (Run.matcher_token v1),
                  trans_real_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Super_rela_op_real_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_super (Run.matcher_token v0),
                  trans_relational_operator (Run.matcher_token v1),
                  trans_real_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_relational_pattern ((kind, body) : mt) : CST.relational_pattern =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_rela_op_real_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  (match v0 with
                  | Alt (0, v) ->
                      `Rela_op (
                        trans_relational_operator (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Equa_op (
                        trans_equality_operator (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_real_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Un_pat (
            trans_unary_pattern (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_rest_pattern ((kind, body) : mt) : CST.rest_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_pattern (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_return_statement ((kind, body) : mt) : CST.return_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_expression (Run.matcher_token v))
              v1
            ,
            trans_semicolon (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_selector ((kind, body) : mt) : CST.selector =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Excl_op (
            trans_exclamation_operator (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Assi_sele (
            trans_assignable_selector (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Arg_part (
            trans_argument_part (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Type_args (
            trans_type_arguments (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_set_or_map_literal ((kind, body) : mt) : CST.set_or_map_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.opt
              (fun v -> trans_const_builtin (Run.matcher_token v))
              v0
            ,
            Run.opt
              (fun v -> trans_type_arguments (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_element (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_element (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                      ,
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v2
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_shift_expression ((kind, body) : mt) : CST.shift_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Real_exp_rep1_shift_op_real_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_real_expression (Run.matcher_token v0),
                  Run.repeat1
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_shift_operator (Run.matcher_token v0),
                            trans_real_expression (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Super_rep1_shift_op_real_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_super (Run.matcher_token v0),
                  Run.repeat1
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_shift_operator (Run.matcher_token v0),
                            trans_real_expression (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_simple_formal_parameter ((kind, body) : mt) : CST.simple_formal_parameter =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Decl_id (
            trans_declared_identifier (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Opt_cova_id (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.opt
                    (fun v -> trans_covariant (Run.matcher_token v))
                    v0
                  ,
                  trans_identifier (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spread_element ((kind, body) : mt) : CST.spread_element =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v1
            ,
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_statement ((kind, body) : mt) : CST.statement =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Blk (
            trans_block (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Local_func_decl (
            trans_local_function_declaration (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Local_var_decl (
            trans_local_variable_declaration (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `For_stmt (
            trans_for_statement (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `While_stmt (
            trans_while_statement (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Do_stmt (
            trans_do_statement (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Switch_stmt (
            trans_switch_statement (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `If_stmt (
            trans_if_statement (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Try_stmt (
            trans_try_statement (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Brk_stmt (
            trans_break_statement (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Cont_stmt (
            trans_continue_statement (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Ret_stmt (
            trans_return_statement (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Yield_stmt (
            trans_yield_statement (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Yield_each_stmt (
            trans_yield_each_statement (Run.matcher_token v)
          )
      | Alt (14, v) ->
          `Exp_stmt (
            trans_expression_statement (Run.matcher_token v)
          )
      | Alt (15, v) ->
          `Assert_stmt (
            trans_assert_statement (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_strict_formal_parameter_list ((kind, body) : mt) : CST.strict_formal_parameter_list =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `LPAR_RPAR (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `LPAR_normal_formal_params_opt_COMMA_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_normal_formal_parameters (Run.matcher_token v1),
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v2
                  ,
                  Run.trans_token (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `LPAR_normal_formal_params_COMMA_opt_formal_params_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_normal_formal_parameters (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2),
                  trans_optional_formal_parameters (Run.matcher_token v3),
                  Run.trans_token (Run.matcher_token v4)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `LPAR_opt_formal_params_RPAR (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_optional_formal_parameters (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_string_literal ((kind, body) : mt) : CST.string_literal =
  match body with
  | Children v ->
      Run.repeat1
        (fun v ->
          (match v with
          | Alt (0, v) ->
              `Str_lit_double_quotes (
                trans_string_literal_double_quotes (Run.matcher_token v)
              )
          | Alt (1, v) ->
              `Str_lit_single_quotes (
                trans_string_literal_single_quotes (Run.matcher_token v)
              )
          | Alt (2, v) ->
              `Str_lit_double_quotes_mult (
                trans_string_literal_double_quotes_multiple (Run.matcher_token v)
              )
          | Alt (3, v) ->
              `Str_lit_single_quotes_mult (
                trans_string_literal_single_quotes_multiple (Run.matcher_token v)
              )
          | Alt (4, v) ->
              `Raw_str_lit_double_quotes (
                trans_raw_string_literal_double_quotes (Run.matcher_token v)
              )
          | Alt (5, v) ->
              `Raw_str_lit_single_quotes (
                trans_raw_string_literal_single_quotes (Run.matcher_token v)
              )
          | Alt (6, v) ->
              `Raw_str_lit_double_quotes_mult (
                trans_raw_string_literal_double_quotes_multiple (Run.matcher_token v)
              )
          | Alt (7, v) ->
              `Raw_str_lit_single_quotes_mult (
                trans_raw_string_literal_single_quotes_multiple (Run.matcher_token v)
              )
          | _ -> assert false
          )
        )
        v
  | Leaf _ -> assert false

and trans_string_literal_double_quotes ((kind, body) : mt) : CST.string_literal_double_quotes =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Temp_chars_double_single (
                      trans_template_chars_double_single (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `SQUOT (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `Esc_seq (
                      trans_escape_sequence (Run.matcher_token v)
                    )
                | Alt (3, v) ->
                    `Sub_str_test (
                      trans_sub_string_test (Run.matcher_token v)
                    )
                | Alt (4, v) ->
                    `Temp_subs (
                      trans_template_substitution (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_string_literal_double_quotes_multiple ((kind, body) : mt) : CST.string_literal_double_quotes_multiple =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Temp_chars_double (
                      trans_template_chars_double (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `SQUOT (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `DQUOT (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (3, v) ->
                    `Esc_seq (
                      trans_escape_sequence (Run.matcher_token v)
                    )
                | Alt (4, v) ->
                    `Sub_str_test (
                      trans_sub_string_test (Run.matcher_token v)
                    )
                | Alt (5, v) ->
                    `Temp_subs (
                      trans_template_substitution (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_string_literal_single_quotes ((kind, body) : mt) : CST.string_literal_single_quotes =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Temp_chars_single_single (
                      trans_template_chars_single_single (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `DQUOT (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `Esc_seq (
                      trans_escape_sequence (Run.matcher_token v)
                    )
                | Alt (3, v) ->
                    `Sub_str_test (
                      trans_sub_string_test (Run.matcher_token v)
                    )
                | Alt (4, v) ->
                    `Temp_subs (
                      trans_template_substitution (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_string_literal_single_quotes_multiple ((kind, body) : mt) : CST.string_literal_single_quotes_multiple =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Temp_chars_single (
                      trans_template_chars_single (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `DQUOT (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `SQUOT (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (3, v) ->
                    `Esc_seq (
                      trans_escape_sequence (Run.matcher_token v)
                    )
                | Alt (4, v) ->
                    `Sub_str_test (
                      trans_sub_string_test (Run.matcher_token v)
                    )
                | Alt (5, v) ->
                    `Temp_subs (
                      trans_template_substitution (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_super_formal_parameter ((kind, body) : mt) : CST.super_formal_parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.opt
              (fun v ->
                trans_final_const_var_or_type (Run.matcher_token v)
              )
              v0
            ,
            trans_super (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_identifier (Run.matcher_token v3),
            Run.opt
              (fun v -> trans_formal_parameter_part (Run.matcher_token v))
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_switch_block ((kind, body) : mt) : CST.switch_block =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_switch_statement_case (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v ->
                trans_switch_statement_default (Run.matcher_token v)
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_switch_expression ((kind, body) : mt) : CST.switch_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_parenthesized_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_switch_expression_case (Run.matcher_token v3),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_switch_expression_case (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v4
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v5
            ,
            Run.trans_token (Run.matcher_token v6)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_switch_expression_case ((kind, body) : mt) : CST.switch_expression_case =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_guarded_pattern (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_switch_statement ((kind, body) : mt) : CST.switch_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_parenthesized_expression (Run.matcher_token v1),
            trans_switch_block (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_switch_statement_case ((kind, body) : mt) : CST.switch_statement_case =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.repeat
              (fun v -> trans_label (Run.matcher_token v))
              v0
            ,
            trans_case_builtin (Run.matcher_token v1),
            trans_guarded_pattern (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            Run.repeat
              (fun v -> trans_statement (Run.matcher_token v))
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_switch_statement_default ((kind, body) : mt) : CST.switch_statement_default =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.repeat
              (fun v -> trans_label (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            Run.repeat
              (fun v -> trans_statement (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_template_substitution ((kind, body) : mt) : CST.template_substitution =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `LCURL_exp_RCURL (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_expression (Run.matcher_token v1),
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Id_dollar_esca (
                  trans_identifier_dollar_escaped (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_throw_expression ((kind, body) : mt) : CST.throw_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_throw_expression_without_cascade ((kind, body) : mt) : CST.throw_expression_without_cascade =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression_without_cascade (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_try_head ((kind, body) : mt) : CST.try_head =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_block (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_try_statement ((kind, body) : mt) : CST.try_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_try_head (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Fina_clause (
                      trans_finally_clause (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Rep1_on_part_opt_fina_clause (
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.repeat1
                              (fun v -> trans_on_part (Run.matcher_token v))
                              v0
                            ,
                            Run.opt
                              (fun v -> trans_finally_clause (Run.matcher_token v))
                              v1
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_ ((kind, body) : mt) : CST.type_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Func_type_opt_null_type (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_function_type (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_nullable_type (Run.matcher_token v))
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Type_not_func (
            trans_type_not_function (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_arguments ((kind, body) : mt) : CST.type_arguments =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `LT_opt_type_rep_COMMA_type_GT (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_type_ (Run.matcher_token v0),
                            Run.repeat
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      Run.trans_token (Run.matcher_token v0),
                                      trans_type_ (Run.matcher_token v1)
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_bound ((kind, body) : mt) : CST.type_bound =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_not_void (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_cast ((kind, body) : mt) : CST.type_cast =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_as_operator (Run.matcher_token v0),
            trans_type_not_void (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_cast_expression ((kind, body) : mt) : CST.type_cast_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_real_expression (Run.matcher_token v0),
            trans_type_cast (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_not_function ((kind, body) : mt) : CST.type_not_function =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Type_not_void_not_func (
            trans_type_not_void_not_function (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Record_type_opt_null_type (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_record_type (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_nullable_type (Run.matcher_token v))
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Void_type (
            trans_void_type (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_not_void ((kind, body) : mt) : CST.type_not_void =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Func_type_opt_null_type (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_function_type (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_nullable_type (Run.matcher_token v))
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Record_type_opt_null_type (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_record_type (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_nullable_type (Run.matcher_token v))
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Type_not_void_not_func (
            trans_type_not_void_not_function (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_not_void_not_function ((kind, body) : mt) : CST.type_not_void_not_function =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Type_name_opt_type_args_opt_null_type (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_type_name (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_type_arguments (Run.matcher_token v))
                    v1
                  ,
                  Run.opt
                    (fun v -> trans_nullable_type (Run.matcher_token v))
                    v2
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Func_buil_id_opt_null_type (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_function_builtin_identifier (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_nullable_type (Run.matcher_token v))
                    v1
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_parameter ((kind, body) : mt) : CST.type_parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_metadata (Run.matcher_token v))
              v0
            ,
            (match v1 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Null_type (
                  trans_nullable_type (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v -> trans_nullable_type (Run.matcher_token v))
              v2
            ,
            Run.opt
              (fun v -> trans_type_bound (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_parameters ((kind, body) : mt) : CST.type_parameters =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_parameter (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_parameter (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_test ((kind, body) : mt) : CST.type_test =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_is_operator (Run.matcher_token v0),
            trans_type_not_void (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_test_expression ((kind, body) : mt) : CST.type_test_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_real_expression (Run.matcher_token v0),
            trans_type_test (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_typed_identifier ((kind, body) : mt) : CST.typed_identifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_type_ (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unary_expression ((kind, body) : mt) : CST.unary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Post_exp (
            trans_postfix_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Un_exp_ (
            trans_unary_expression_ (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unary_expression_ ((kind, body) : mt) : CST.unary_expression_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Prefix_op_un_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_prefix_operator (Run.matcher_token v0),
                  trans_unary_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Await_exp (
            trans_await_expression (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Choice_minus_op_super (
            (match v with
            | Seq [v0; v1] ->
                (
                  (match v0 with
                  | Alt (0, v) ->
                      `Minus_op (
                        trans_minus_operator (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Tilde_op (
                        trans_tilde_operator (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_super (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Incr_op_assi_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_increment_operator (Run.matcher_token v0),
                  trans_assignable_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unary_pattern ((kind, body) : mt) : CST.unary_pattern =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Cast_pat (
            trans_cast_pattern (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Null_check_pat (
            trans_null_check_pattern (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Null_assert_pat (
            trans_null_assert_pattern (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Prim_pat (
            trans_primary_pattern (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unconditional_assignable_selector ((kind, body) : mt) : CST.unconditional_assignable_selector =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Index_sele (
            trans_index_selector (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `DOT_id (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_identifier (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_var_or_type ((kind, body) : mt) : CST.var_or_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Type (
            trans_type_ (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Infe_type_opt_type (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_inferred_type (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_type_ (Run.matcher_token v))
                    v1
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_variable_pattern ((kind, body) : mt) : CST.variable_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_final_var_or_type (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_while_statement ((kind, body) : mt) : CST.while_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_parenthesized_expression (Run.matcher_token v1),
            trans_statement (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_yield_each_statement ((kind, body) : mt) : CST.yield_each_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            trans_semicolon (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_yield_statement ((kind, body) : mt) : CST.yield_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            trans_semicolon (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_enum_constant ((kind, body) : mt) : CST.enum_constant =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_meta_id_opt_arg_part (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.opt
                    (fun v -> trans_metadata (Run.matcher_token v))
                    v0
                  ,
                  trans_identifier (Run.matcher_token v1),
                  Run.opt
                    (fun v -> trans_argument_part (Run.matcher_token v))
                    v2
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Opt_meta_id_opt_type_args_DOT_choice_id_args (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5] ->
                (
                  Run.opt
                    (fun v -> trans_metadata (Run.matcher_token v))
                    v0
                  ,
                  trans_identifier (Run.matcher_token v1),
                  Run.opt
                    (fun v -> trans_type_arguments (Run.matcher_token v))
                    v2
                  ,
                  Run.trans_token (Run.matcher_token v3),
                  (match v4 with
                  | Alt (0, v) ->
                      `Id (
                        trans_identifier (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `New_buil (
                        trans_new_builtin (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_arguments (Run.matcher_token v5)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_operator_signature ((kind, body) : mt) : CST.operator_signature =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.opt
              (fun v -> trans_type_ (Run.matcher_token v))
              v0
            ,
            trans_operator (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `TILDE (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Bin_op (
                  trans_binary_operator (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `LBRACKRBRACK (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `LBRACKRBRACKEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_formal_parameter_list (Run.matcher_token v3),
            Run.opt
              (fun v -> trans_native (Run.matcher_token v))
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_redirection ((kind, body) : mt) : CST.redirection =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_this (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier_or_new (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            trans_arguments (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_library_name ((kind, body) : mt) : CST.library_name =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_metadata (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_dotted_identifier_list (Run.matcher_token v2),
            trans_semicolon (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_static_final_declaration ((kind, body) : mt) : CST.static_final_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false




let trans_redirecting_factory_constructor_signature ((kind, body) : mt) : CST.redirecting_factory_constructor_signature =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7] ->
          (
            Run.opt
              (fun v -> trans_const_builtin (Run.matcher_token v))
              v0
            ,
            trans_factory (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            trans_formal_parameter_list (Run.matcher_token v4),
            Run.trans_token (Run.matcher_token v5),
            trans_type_not_void (Run.matcher_token v6),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v7
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_uri ((kind, body) : mt) : CST.uri =
  match body with
  | Children v ->
      trans_string_literal (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_constructor_signature ((kind, body) : mt) : CST.constructor_signature =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier_or_new (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_formal_parameter_list (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false



let trans_setter_signature ((kind, body) : mt) : CST.setter_signature =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.opt
              (fun v -> trans_type_ (Run.matcher_token v))
              v0
            ,
            trans_set (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            trans_formal_parameter_part (Run.matcher_token v3),
            Run.opt
              (fun v -> trans_native (Run.matcher_token v))
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_field_initializer ((kind, body) : mt) : CST.field_initializer =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_this (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            trans_identifier (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_real_expression (Run.matcher_token v3),
            Run.repeat
              (fun v -> trans_cascade_section (Run.matcher_token v))
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_type_not_void_list ((kind, body) : mt) : CST.type_not_void_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_type_not_void (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_not_void (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_constant_constructor_signature ((kind, body) : mt) : CST.constant_constructor_signature =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_const_builtin (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier_or_new (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            trans_formal_parameter_list (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false



let trans_factory_constructor_signature ((kind, body) : mt) : CST.factory_constructor_signature =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_factory (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            trans_formal_parameter_list (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_uri_test ((kind, body) : mt) : CST.uri_test =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_dotted_identifier_list (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_string_literal (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_getter_signature ((kind, body) : mt) : CST.getter_signature =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_type_ (Run.matcher_token v))
              v0
            ,
            trans_get (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_native (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_type_alias ((kind, body) : mt) : CST.type_alias =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_meta_type_opt_type_type_name_formal_param_part_SEMI (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5] ->
                (
                  Run.opt
                    (fun v -> trans_metadata (Run.matcher_token v))
                    v0
                  ,
                  trans_typedef (Run.matcher_token v1),
                  Run.opt
                    (fun v -> trans_type_ (Run.matcher_token v))
                    v2
                  ,
                  trans_type_name (Run.matcher_token v3),
                  trans_formal_parameter_part (Run.matcher_token v4),
                  Run.trans_token (Run.matcher_token v5)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Opt_meta_type_type_name_opt_type_params_EQ_type_SEMI (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5; v6] ->
                (
                  Run.opt
                    (fun v -> trans_metadata (Run.matcher_token v))
                    v0
                  ,
                  trans_typedef (Run.matcher_token v1),
                  trans_type_name (Run.matcher_token v2),
                  Run.opt
                    (fun v -> trans_type_parameters (Run.matcher_token v))
                    v3
                  ,
                  Run.trans_token (Run.matcher_token v4),
                  trans_type_ (Run.matcher_token v5),
                  Run.trans_token (Run.matcher_token v6)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false



let trans_semgrep_pattern ((kind, body) : mt) : CST.semgrep_pattern =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp (
            trans_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Stmt (
            trans_statement (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_initialized_identifier_list ((kind, body) : mt) : CST.initialized_identifier_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_initialized_identifier (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_initialized_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_static_final_declaration_list ((kind, body) : mt) : CST.static_final_declaration_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_static_final_declaration (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_static_final_declaration (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_part_of_directive ((kind, body) : mt) : CST.part_of_directive =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_metadata (Run.matcher_token v))
              v0
            ,
            trans_part_of_builtin (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Dotted_id_list (
                  trans_dotted_identifier_list (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Uri (
                  trans_uri (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_semicolon (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_part_directive ((kind, body) : mt) : CST.part_directive =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_metadata (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_uri (Run.matcher_token v2),
            trans_semicolon (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_initializer_list_entry ((kind, body) : mt) : CST.initializer_list_entry =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Super_args (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_super (Run.matcher_token v0),
                  trans_arguments (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Super_DOT_choice_id_args (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  trans_super (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  (match v2 with
                  | Alt (0, v) ->
                      `Id (
                        trans_identifier (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `New_buil (
                        trans_new_builtin (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_arguments (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Field_init (
            trans_field_initializer (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Asse (
            trans_assertion (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_mixins ((kind, body) : mt) : CST.mixins =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_not_void_list (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_interfaces ((kind, body) : mt) : CST.interfaces =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_implements (Run.matcher_token v0),
            trans_type_not_void_list (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_configuration_uri_condition ((kind, body) : mt) : CST.configuration_uri_condition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_uri_test (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_semgrep_expression ((kind, body) : mt) : CST.semgrep_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_semgrep_pattern (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_initializers ((kind, body) : mt) : CST.initializers =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_initializer_list_entry (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_initializer_list_entry (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_superclass ((kind, body) : mt) : CST.superclass =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Extends_type_not_void_opt_mixins (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_type_not_void (Run.matcher_token v1),
                  Run.opt
                    (fun v -> trans_mixins (Run.matcher_token v))
                    v2
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Mixins (
            trans_mixins (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_mixin_application ((kind, body) : mt) : CST.mixin_application =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_type_not_void (Run.matcher_token v0),
            trans_mixins (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_interfaces (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_configuration_uri ((kind, body) : mt) : CST.configuration_uri =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_configuration_uri_condition (Run.matcher_token v1),
            trans_uri (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_method_signature ((kind, body) : mt) : CST.method_signature =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Cons_sign_opt_initis (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_constructor_signature (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_initializers (Run.matcher_token v))
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Fact_cons_sign (
            trans_factory_constructor_signature (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Opt_static_choice_func_sign (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.opt
                    (fun v -> trans_static (Run.matcher_token v))
                    v0
                  ,
                  (match v1 with
                  | Alt (0, v) ->
                      `Func_sign (
                        trans_function_signature (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Getter_sign (
                        trans_getter_signature (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `Setter_sign (
                        trans_setter_signature (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Op_sign (
            trans_operator_signature (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_declaration_ ((kind, body) : mt) : CST.declaration_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Cst_cons_sign_opt_choice_redi (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_constant_constructor_signature (Run.matcher_token v0),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Alt (0, v) ->
                          `Redi (
                            trans_redirection (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Initis (
                            trans_initializers (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Cons_sign_opt_choice_redi (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_constructor_signature (Run.matcher_token v0),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Alt (0, v) ->
                          `Redi (
                            trans_redirection (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Initis (
                            trans_initializers (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Exte_opt_const_buil_fact_cons_sign (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_external_ (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_const_builtin (Run.matcher_token v))
                    v1
                  ,
                  trans_factory_constructor_signature (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Opt_const_buil_fact_cons_sign_native (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.opt
                    (fun v -> trans_const_builtin (Run.matcher_token v))
                    v0
                  ,
                  trans_factory_constructor_signature (Run.matcher_token v1),
                  trans_native (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `Exte_cst_cons_sign (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_external_ (Run.matcher_token v0),
                  trans_constant_constructor_signature (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (5, v) ->
          `Redi_fact_cons_sign (
            trans_redirecting_factory_constructor_signature (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Exte_cons_sign (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_external_ (Run.matcher_token v0),
                  trans_constructor_signature (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (7, v) ->
          `Opt_exte_buil_opt_static_getter_sign (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.opt
                    (fun v -> trans_external_builtin (Run.matcher_token v))
                    v0
                  ,
                  Run.opt
                    (fun v -> trans_static (Run.matcher_token v))
                    v1
                  ,
                  trans_getter_signature (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (8, v) ->
          `Opt_exte_and_static_setter_sign (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.opt
                    (fun v -> trans_external_and_static (Run.matcher_token v))
                    v0
                  ,
                  trans_setter_signature (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (9, v) ->
          `Opt_exte_op_sign (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.opt
                    (fun v -> trans_external_ (Run.matcher_token v))
                    v0
                  ,
                  trans_operator_signature (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (10, v) ->
          `Opt_exte_and_static_func_sign (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.opt
                    (fun v -> trans_external_and_static (Run.matcher_token v))
                    v0
                  ,
                  trans_function_signature (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (11, v) ->
          `Static_func_sign (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_static (Run.matcher_token v0),
                  trans_function_signature (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (12, v) ->
          `Static_choice_final_or_const_opt_type_static_final_decl_list (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_static (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `Final_or_const_opt_type_static_final_decl_list (
                        (match v with
                        | Seq [v0; v1; v2] ->
                            (
                              trans_final_or_const (Run.matcher_token v0),
                              Run.opt
                                (fun v -> trans_type_ (Run.matcher_token v))
                                v1
                              ,
                              trans_static_final_declaration_list (Run.matcher_token v2)
                            )
                        | _ -> assert false
                        )
                      )
                  | Alt (1, v) ->
                      `Late_buil_choice_final_buil_opt_type_init_id_list (
                        (match v with
                        | Seq [v0; v1] ->
                            (
                              trans_late_builtin (Run.matcher_token v0),
                              (match v1 with
                              | Alt (0, v) ->
                                  `Final_buil_opt_type_init_id_list (
                                    (match v with
                                    | Seq [v0; v1; v2] ->
                                        (
                                          trans_final_builtin (Run.matcher_token v0),
                                          Run.opt
                                            (fun v -> trans_type_ (Run.matcher_token v))
                                            v1
                                          ,
                                          trans_initialized_identifier_list (Run.matcher_token v2)
                                        )
                                    | _ -> assert false
                                    )
                                  )
                              | Alt (1, v) ->
                                  `Choice_type_init_id_list (
                                    (match v with
                                    | Seq [v0; v1] ->
                                        (
                                          (match v0 with
                                          | Alt (0, v) ->
                                              `Type (
                                                trans_type_ (Run.matcher_token v)
                                              )
                                          | Alt (1, v) ->
                                              `Infe_type (
                                                trans_inferred_type (Run.matcher_token v)
                                              )
                                          | _ -> assert false
                                          )
                                          ,
                                          trans_initialized_identifier_list (Run.matcher_token v1)
                                        )
                                    | _ -> assert false
                                    )
                                  )
                              | _ -> assert false
                              )
                            )
                        | _ -> assert false
                        )
                      )
                  | Alt (2, v) ->
                      `Choice_type_init_id_list (
                        (match v with
                        | Seq [v0; v1] ->
                            (
                              (match v0 with
                              | Alt (0, v) ->
                                  `Type (
                                    trans_type_ (Run.matcher_token v)
                                  )
                              | Alt (1, v) ->
                                  `Infe_type (
                                    trans_inferred_type (Run.matcher_token v)
                                  )
                              | _ -> assert false
                              )
                              ,
                              trans_initialized_identifier_list (Run.matcher_token v1)
                            )
                        | _ -> assert false
                        )
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | Alt (13, v) ->
          `Cova_choice_late_buil_choice_final_buil_opt_type_id_list_ (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_covariant (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `Late_buil_choice_final_buil_opt_type_id_list_ (
                        (match v with
                        | Seq [v0; v1] ->
                            (
                              trans_late_builtin (Run.matcher_token v0),
                              (match v1 with
                              | Alt (0, v) ->
                                  `Final_buil_opt_type_id_list_ (
                                    (match v with
                                    | Seq [v0; v1; v2] ->
                                        (
                                          trans_final_builtin (Run.matcher_token v0),
                                          Run.opt
                                            (fun v -> trans_type_ (Run.matcher_token v))
                                            v1
                                          ,
                                          trans_identifier_list_ (Run.matcher_token v2)
                                        )
                                    | _ -> assert false
                                    )
                                  )
                              | Alt (1, v) ->
                                  `Choice_type_init_id_list (
                                    (match v with
                                    | Seq [v0; v1] ->
                                        (
                                          (match v0 with
                                          | Alt (0, v) ->
                                              `Type (
                                                trans_type_ (Run.matcher_token v)
                                              )
                                          | Alt (1, v) ->
                                              `Infe_type (
                                                trans_inferred_type (Run.matcher_token v)
                                              )
                                          | _ -> assert false
                                          )
                                          ,
                                          trans_initialized_identifier_list (Run.matcher_token v1)
                                        )
                                    | _ -> assert false
                                    )
                                  )
                              | _ -> assert false
                              )
                            )
                        | _ -> assert false
                        )
                      )
                  | Alt (1, v) ->
                      `Choice_type_init_id_list (
                        (match v with
                        | Seq [v0; v1] ->
                            (
                              (match v0 with
                              | Alt (0, v) ->
                                  `Type (
                                    trans_type_ (Run.matcher_token v)
                                  )
                              | Alt (1, v) ->
                                  `Infe_type (
                                    trans_inferred_type (Run.matcher_token v)
                                  )
                              | _ -> assert false
                              )
                              ,
                              trans_initialized_identifier_list (Run.matcher_token v1)
                            )
                        | _ -> assert false
                        )
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | Alt (14, v) ->
          `Opt_late_buil_final_buil_opt_type_init_id_list (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.opt
                    (fun v -> trans_late_builtin (Run.matcher_token v))
                    v0
                  ,
                  trans_final_builtin (Run.matcher_token v1),
                  Run.opt
                    (fun v -> trans_type_ (Run.matcher_token v))
                    v2
                  ,
                  trans_initialized_identifier_list (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | Alt (15, v) ->
          `Opt_late_buil_var_or_type_init_id_list (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.opt
                    (fun v -> trans_late_builtin (Run.matcher_token v))
                    v0
                  ,
                  trans_var_or_type (Run.matcher_token v1),
                  trans_initialized_identifier_list (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_mixin_application_class ((kind, body) : mt) : CST.mixin_application_class =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_parameters (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            trans_mixin_application (Run.matcher_token v3),
            trans_semicolon (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_configurable_uri ((kind, body) : mt) : CST.configurable_uri =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_uri (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_configuration_uri (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_class_body ((kind, body) : mt) : CST.class_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.opt
                        (fun v -> trans_metadata (Run.matcher_token v))
                        v0
                      ,
                      (match v1 with
                      | Alt (0, v) ->
                          `Decl__semi (
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  trans_declaration_ (Run.matcher_token v0),
                                  trans_semicolon (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                      | Alt (1, v) ->
                          `Meth_sign_func_body (
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  trans_method_signature (Run.matcher_token v0),
                                  trans_function_body (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_enum_body ((kind, body) : mt) : CST.enum_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_enum_constant (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_enum_constant (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v3
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.opt
                                  (fun v -> trans_metadata (Run.matcher_token v))
                                  v0
                                ,
                                (match v1 with
                                | Alt (0, v) ->
                                    `Decl__semi (
                                      (match v with
                                      | Seq [v0; v1] ->
                                          (
                                            trans_declaration_ (Run.matcher_token v0),
                                            trans_semicolon (Run.matcher_token v1)
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                | Alt (1, v) ->
                                    `Meth_sign_func_body (
                                      (match v with
                                      | Seq [v0; v1] ->
                                          (
                                            trans_method_signature (Run.matcher_token v0),
                                            trans_function_body (Run.matcher_token v1)
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                | _ -> assert false
                                )
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v4
            ,
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_extension_body ((kind, body) : mt) : CST.extension_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Opt_meta_decl__semi (
                      (match v with
                      | Seq [v0; v1; v2] ->
                          (
                            Run.opt
                              (fun v -> trans_metadata (Run.matcher_token v))
                              v0
                            ,
                            trans_declaration_ (Run.matcher_token v1),
                            trans_semicolon (Run.matcher_token v2)
                          )
                      | _ -> assert false
                      )
                    )
                | Alt (1, v) ->
                    `Opt_meta_meth_sign_func_body (
                      (match v with
                      | Seq [v0; v1; v2] ->
                          (
                            Run.opt
                              (fun v -> trans_metadata (Run.matcher_token v))
                              v0
                            ,
                            trans_method_signature (Run.matcher_token v1),
                            trans_function_body (Run.matcher_token v2)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_import_specification ((kind, body) : mt) : CST.import_specification =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Import_conf_uri_opt_as_id_rep_comb_semi (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  trans_import (Run.matcher_token v0),
                  trans_configurable_uri (Run.matcher_token v1),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_as_ (Run.matcher_token v0),
                            trans_identifier (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v2
                  ,
                  Run.repeat
                    (fun v -> trans_combinator (Run.matcher_token v))
                    v3
                  ,
                  trans_semicolon (Run.matcher_token v4)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Import_uri_defe_as_id_rep_comb_semi (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5; v6] ->
                (
                  trans_import (Run.matcher_token v0),
                  trans_uri (Run.matcher_token v1),
                  trans_deferred (Run.matcher_token v2),
                  trans_as_ (Run.matcher_token v3),
                  trans_identifier (Run.matcher_token v4),
                  Run.repeat
                    (fun v -> trans_combinator (Run.matcher_token v))
                    v5
                  ,
                  trans_semicolon (Run.matcher_token v6)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_library_export ((kind, body) : mt) : CST.library_export =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.opt
              (fun v -> trans_metadata (Run.matcher_token v))
              v0
            ,
            trans_export (Run.matcher_token v1),
            trans_configurable_uri (Run.matcher_token v2),
            Run.repeat
              (fun v -> trans_combinator (Run.matcher_token v))
              v3
            ,
            trans_semicolon (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_class_definition ((kind, body) : mt) : CST.class_definition =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_meta_choice_class_modifs_id_opt_type_params_opt_supe_opt_inters_class_body (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5; v6] ->
                (
                  Run.opt
                    (fun v -> trans_metadata (Run.matcher_token v))
                    v0
                  ,
                  (match v1 with
                  | Alt (0, v) ->
                      `Class_modifs (
                        trans_class_modifiers (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Mixin_class_modifs (
                        trans_mixin_class_modifiers (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_identifier (Run.matcher_token v2),
                  Run.opt
                    (fun v -> trans_type_parameters (Run.matcher_token v))
                    v3
                  ,
                  Run.opt
                    (fun v -> trans_superclass (Run.matcher_token v))
                    v4
                  ,
                  Run.opt
                    (fun v -> trans_interfaces (Run.matcher_token v))
                    v5
                  ,
                  trans_class_body (Run.matcher_token v6)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Opt_meta_class_modifs_mixin_app_class (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.opt
                    (fun v -> trans_metadata (Run.matcher_token v))
                    v0
                  ,
                  trans_class_modifiers (Run.matcher_token v1),
                  trans_mixin_application_class (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_mixin_declaration ((kind, body) : mt) : CST.mixin_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7] ->
          (
            Run.opt
              (fun v -> trans_metadata (Run.matcher_token v))
              v0
            ,
            Run.opt
              (fun v -> trans_base (Run.matcher_token v))
              v1
            ,
            trans_mixin (Run.matcher_token v2),
            trans_identifier (Run.matcher_token v3),
            Run.opt
              (fun v -> trans_type_parameters (Run.matcher_token v))
              v4
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_not_void_list (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v5
            ,
            Run.opt
              (fun v -> trans_interfaces (Run.matcher_token v))
              v6
            ,
            trans_class_body (Run.matcher_token v7)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_enum_declaration ((kind, body) : mt) : CST.enum_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.opt
              (fun v -> trans_metadata (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_type_parameters (Run.matcher_token v))
              v3
            ,
            Run.opt
              (fun v -> trans_mixins (Run.matcher_token v))
              v4
            ,
            Run.opt
              (fun v -> trans_interfaces (Run.matcher_token v))
              v5
            ,
            trans_enum_body (Run.matcher_token v6)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_extension_declaration ((kind, body) : mt) : CST.extension_declaration =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_meta_exte_opt_id_opt_type_params_on_type_exte_body (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5; v6] ->
                (
                  Run.opt
                    (fun v -> trans_metadata (Run.matcher_token v))
                    v0
                  ,
                  Run.trans_token (Run.matcher_token v1),
                  Run.opt
                    (fun v -> trans_identifier (Run.matcher_token v))
                    v2
                  ,
                  Run.opt
                    (fun v -> trans_type_parameters (Run.matcher_token v))
                    v3
                  ,
                  Run.trans_token (Run.matcher_token v4),
                  trans_type_ (Run.matcher_token v5),
                  trans_extension_body (Run.matcher_token v6)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_library_import ((kind, body) : mt) : CST.library_import =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v -> trans_metadata (Run.matcher_token v))
              v0
            ,
            trans_import_specification (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_top_level_definition ((kind, body) : mt) : CST.top_level_definition =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Class_defi (
            trans_class_definition (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Mixin_decl (
            trans_mixin_declaration (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Exte_decl (
            trans_extension_declaration (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Enum_decl (
            trans_enum_declaration (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Type_alias (
            trans_type_alias (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Opt_meta_opt_exte_buil_func_sign_semi (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.opt
                    (fun v -> trans_metadata (Run.matcher_token v))
                    v0
                  ,
                  Run.opt
                    (fun v -> trans_external_builtin (Run.matcher_token v))
                    v1
                  ,
                  trans_function_signature (Run.matcher_token v2),
                  trans_semicolon (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | Alt (6, v) ->
          `Opt_meta_opt_exte_buil_getter_sign_semi (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.opt
                    (fun v -> trans_metadata (Run.matcher_token v))
                    v0
                  ,
                  Run.opt
                    (fun v -> trans_external_builtin (Run.matcher_token v))
                    v1
                  ,
                  trans_getter_signature (Run.matcher_token v2),
                  trans_semicolon (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | Alt (7, v) ->
          `Opt_meta_opt_exte_buil_setter_sign_semi (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.opt
                    (fun v -> trans_metadata (Run.matcher_token v))
                    v0
                  ,
                  Run.opt
                    (fun v -> trans_external_builtin (Run.matcher_token v))
                    v1
                  ,
                  trans_setter_signature (Run.matcher_token v2),
                  trans_semicolon (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | Alt (8, v) ->
          `Opt_meta_getter_sign_func_body (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.opt
                    (fun v -> trans_metadata (Run.matcher_token v))
                    v0
                  ,
                  trans_getter_signature (Run.matcher_token v1),
                  trans_function_body (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (9, v) ->
          `Opt_meta_setter_sign_func_body (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.opt
                    (fun v -> trans_metadata (Run.matcher_token v))
                    v0
                  ,
                  trans_setter_signature (Run.matcher_token v1),
                  trans_function_body (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (10, v) ->
          `Opt_meta_func_sign_func_body (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.opt
                    (fun v -> trans_metadata (Run.matcher_token v))
                    v0
                  ,
                  trans_function_signature (Run.matcher_token v1),
                  trans_function_body (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (11, v) ->
          `Opt_meta_choice_final_buil_opt_type_static_final_decl_list_semi (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  Run.opt
                    (fun v -> trans_metadata (Run.matcher_token v))
                    v0
                  ,
                  (match v1 with
                  | Alt (0, v) ->
                      `Final_buil (
                        trans_final_builtin (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Const_buil (
                        trans_const_builtin (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.opt
                    (fun v -> trans_type_ (Run.matcher_token v))
                    v2
                  ,
                  trans_static_final_declaration_list (Run.matcher_token v3),
                  trans_semicolon (Run.matcher_token v4)
                )
            | _ -> assert false
            )
          )
      | Alt (12, v) ->
          `Opt_meta_late_buil_final_buil_opt_type_init_id_list_semi (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5] ->
                (
                  Run.opt
                    (fun v -> trans_metadata (Run.matcher_token v))
                    v0
                  ,
                  trans_late_builtin (Run.matcher_token v1),
                  trans_final_builtin (Run.matcher_token v2),
                  Run.opt
                    (fun v -> trans_type_ (Run.matcher_token v))
                    v3
                  ,
                  trans_initialized_identifier_list (Run.matcher_token v4),
                  trans_semicolon (Run.matcher_token v5)
                )
            | _ -> assert false
            )
          )
      | Alt (13, v) ->
          `Opt_meta_opt_late_buil_choice_type_init_id_list_semi (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  Run.opt
                    (fun v -> trans_metadata (Run.matcher_token v))
                    v0
                  ,
                  Run.opt
                    (fun v -> trans_late_builtin (Run.matcher_token v))
                    v1
                  ,
                  (match v2 with
                  | Alt (0, v) ->
                      `Type (
                        trans_type_ (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Infe_type (
                        trans_inferred_type (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_initialized_identifier_list (Run.matcher_token v3),
                  trans_semicolon (Run.matcher_token v4)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_import_or_export ((kind, body) : mt) : CST.import_or_export =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Libr_import (
            trans_library_import (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Libr_export (
            trans_library_export (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_program ((kind, body) : mt) : CST.program =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_script_tag_opt_libr_name_rep_import_or_export_rep_part_dire_rep_part_of_dire_rep_top_level_defi (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5] ->
                (
                  Run.opt
                    (fun v -> trans_script_tag (Run.matcher_token v))
                    v0
                  ,
                  Run.opt
                    (fun v -> trans_library_name (Run.matcher_token v))
                    v1
                  ,
                  Run.repeat
                    (fun v -> trans_import_or_export (Run.matcher_token v))
                    v2
                  ,
                  Run.repeat
                    (fun v -> trans_part_directive (Run.matcher_token v))
                    v3
                  ,
                  Run.repeat
                    (fun v -> trans_part_of_directive (Run.matcher_token v))
                    v4
                  ,
                  Run.repeat
                    (fun v -> trans_top_level_definition (Run.matcher_token v))
                    v5
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Semg_exp (
            trans_semgrep_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

(*
   Costly operation that translates a whole tree or subtree.

   The first pass translates it into a generic tree structure suitable
   to guess which node corresponds to each grammar rule.
   The second pass is a translation into a typed tree where each grammar
   node has its own type.

   This function is called:
   - once on the root of the program after removing extras
     (comments and other nodes that occur anywhere independently from
     the grammar);
   - once of each extra node, resulting in its own independent tree of type
     'extra'.
*)
let translate_tree src node trans_x =
  let matched_tree = Run.match_tree children_regexps src node in
  Option.map trans_x matched_tree


let translate_extra src (node : Tree_sitter_output_t.node) : CST.extra option =
  match node.type_ with
  | "comment" ->
      (match translate_tree src node trans_comment with
      | None -> None
      | Some x -> Some (`Comment (Run.get_loc node, x)))
  | "documentation_comment" ->
      (match translate_tree src node trans_documentation_comment with
      | None -> None
      | Some x -> Some (`Documentation_comment (Run.get_loc node, x)))
  | _ -> None

let translate_root src root_node =
  translate_tree src root_node trans_program

let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let opt_program, extras =
     Run.translate
       ~extras
       ~translate_root:(translate_root src)
       ~translate_extra:(translate_extra src)
       orig_root_node
  in
  Parsing_result.create src opt_program extras errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree

